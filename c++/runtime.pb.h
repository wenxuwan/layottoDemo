// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: runtime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_runtime_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_runtime_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_runtime_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_runtime_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[70]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_runtime_2eproto;
namespace spec {
namespace proto {
namespace runtime {
namespace v1 {
class BulkStateItem;
struct BulkStateItemDefaultTypeInternal;
extern BulkStateItemDefaultTypeInternal _BulkStateItem_default_instance_;
class BulkStateItem_MetadataEntry_DoNotUse;
struct BulkStateItem_MetadataEntry_DoNotUseDefaultTypeInternal;
extern BulkStateItem_MetadataEntry_DoNotUseDefaultTypeInternal _BulkStateItem_MetadataEntry_DoNotUse_default_instance_;
class CommonInvokeRequest;
struct CommonInvokeRequestDefaultTypeInternal;
extern CommonInvokeRequestDefaultTypeInternal _CommonInvokeRequest_default_instance_;
class ConfigurationItem;
struct ConfigurationItemDefaultTypeInternal;
extern ConfigurationItemDefaultTypeInternal _ConfigurationItem_default_instance_;
class ConfigurationItem_MetadataEntry_DoNotUse;
struct ConfigurationItem_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ConfigurationItem_MetadataEntry_DoNotUseDefaultTypeInternal _ConfigurationItem_MetadataEntry_DoNotUse_default_instance_;
class ConfigurationItem_TagsEntry_DoNotUse;
struct ConfigurationItem_TagsEntry_DoNotUseDefaultTypeInternal;
extern ConfigurationItem_TagsEntry_DoNotUseDefaultTypeInternal _ConfigurationItem_TagsEntry_DoNotUse_default_instance_;
class DelFileRequest;
struct DelFileRequestDefaultTypeInternal;
extern DelFileRequestDefaultTypeInternal _DelFileRequest_default_instance_;
class DeleteBulkStateRequest;
struct DeleteBulkStateRequestDefaultTypeInternal;
extern DeleteBulkStateRequestDefaultTypeInternal _DeleteBulkStateRequest_default_instance_;
class DeleteConfigurationRequest;
struct DeleteConfigurationRequestDefaultTypeInternal;
extern DeleteConfigurationRequestDefaultTypeInternal _DeleteConfigurationRequest_default_instance_;
class DeleteConfigurationRequest_MetadataEntry_DoNotUse;
struct DeleteConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern DeleteConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal _DeleteConfigurationRequest_MetadataEntry_DoNotUse_default_instance_;
class DeleteStateRequest;
struct DeleteStateRequestDefaultTypeInternal;
extern DeleteStateRequestDefaultTypeInternal _DeleteStateRequest_default_instance_;
class DeleteStateRequest_MetadataEntry_DoNotUse;
struct DeleteStateRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern DeleteStateRequest_MetadataEntry_DoNotUseDefaultTypeInternal _DeleteStateRequest_MetadataEntry_DoNotUse_default_instance_;
class Etag;
struct EtagDefaultTypeInternal;
extern EtagDefaultTypeInternal _Etag_default_instance_;
class ExecuteStateTransactionRequest;
struct ExecuteStateTransactionRequestDefaultTypeInternal;
extern ExecuteStateTransactionRequestDefaultTypeInternal _ExecuteStateTransactionRequest_default_instance_;
class ExecuteStateTransactionRequest_MetadataEntry_DoNotUse;
struct ExecuteStateTransactionRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern ExecuteStateTransactionRequest_MetadataEntry_DoNotUseDefaultTypeInternal _ExecuteStateTransactionRequest_MetadataEntry_DoNotUse_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FileInfo_MetadataEntry_DoNotUse;
struct FileInfo_MetadataEntry_DoNotUseDefaultTypeInternal;
extern FileInfo_MetadataEntry_DoNotUseDefaultTypeInternal _FileInfo_MetadataEntry_DoNotUse_default_instance_;
class FileMeta;
struct FileMetaDefaultTypeInternal;
extern FileMetaDefaultTypeInternal _FileMeta_default_instance_;
class FileMetaValue;
struct FileMetaValueDefaultTypeInternal;
extern FileMetaValueDefaultTypeInternal _FileMetaValue_default_instance_;
class FileMeta_MetadataEntry_DoNotUse;
struct FileMeta_MetadataEntry_DoNotUseDefaultTypeInternal;
extern FileMeta_MetadataEntry_DoNotUseDefaultTypeInternal _FileMeta_MetadataEntry_DoNotUse_default_instance_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class FileRequest_MetadataEntry_DoNotUse;
struct FileRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern FileRequest_MetadataEntry_DoNotUseDefaultTypeInternal _FileRequest_MetadataEntry_DoNotUse_default_instance_;
class GetBulkStateRequest;
struct GetBulkStateRequestDefaultTypeInternal;
extern GetBulkStateRequestDefaultTypeInternal _GetBulkStateRequest_default_instance_;
class GetBulkStateRequest_MetadataEntry_DoNotUse;
struct GetBulkStateRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern GetBulkStateRequest_MetadataEntry_DoNotUseDefaultTypeInternal _GetBulkStateRequest_MetadataEntry_DoNotUse_default_instance_;
class GetBulkStateResponse;
struct GetBulkStateResponseDefaultTypeInternal;
extern GetBulkStateResponseDefaultTypeInternal _GetBulkStateResponse_default_instance_;
class GetConfigurationRequest;
struct GetConfigurationRequestDefaultTypeInternal;
extern GetConfigurationRequestDefaultTypeInternal _GetConfigurationRequest_default_instance_;
class GetConfigurationRequest_MetadataEntry_DoNotUse;
struct GetConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern GetConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal _GetConfigurationRequest_MetadataEntry_DoNotUse_default_instance_;
class GetConfigurationResponse;
struct GetConfigurationResponseDefaultTypeInternal;
extern GetConfigurationResponseDefaultTypeInternal _GetConfigurationResponse_default_instance_;
class GetFileMetaRequest;
struct GetFileMetaRequestDefaultTypeInternal;
extern GetFileMetaRequestDefaultTypeInternal _GetFileMetaRequest_default_instance_;
class GetFileMetaResponse;
struct GetFileMetaResponseDefaultTypeInternal;
extern GetFileMetaResponseDefaultTypeInternal _GetFileMetaResponse_default_instance_;
class GetFileRequest;
struct GetFileRequestDefaultTypeInternal;
extern GetFileRequestDefaultTypeInternal _GetFileRequest_default_instance_;
class GetFileRequest_MetadataEntry_DoNotUse;
struct GetFileRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern GetFileRequest_MetadataEntry_DoNotUseDefaultTypeInternal _GetFileRequest_MetadataEntry_DoNotUse_default_instance_;
class GetFileResponse;
struct GetFileResponseDefaultTypeInternal;
extern GetFileResponseDefaultTypeInternal _GetFileResponse_default_instance_;
class GetNextIdRequest;
struct GetNextIdRequestDefaultTypeInternal;
extern GetNextIdRequestDefaultTypeInternal _GetNextIdRequest_default_instance_;
class GetNextIdRequest_MetadataEntry_DoNotUse;
struct GetNextIdRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern GetNextIdRequest_MetadataEntry_DoNotUseDefaultTypeInternal _GetNextIdRequest_MetadataEntry_DoNotUse_default_instance_;
class GetNextIdResponse;
struct GetNextIdResponseDefaultTypeInternal;
extern GetNextIdResponseDefaultTypeInternal _GetNextIdResponse_default_instance_;
class GetStateRequest;
struct GetStateRequestDefaultTypeInternal;
extern GetStateRequestDefaultTypeInternal _GetStateRequest_default_instance_;
class GetStateRequest_MetadataEntry_DoNotUse;
struct GetStateRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern GetStateRequest_MetadataEntry_DoNotUseDefaultTypeInternal _GetStateRequest_MetadataEntry_DoNotUse_default_instance_;
class GetStateResponse;
struct GetStateResponseDefaultTypeInternal;
extern GetStateResponseDefaultTypeInternal _GetStateResponse_default_instance_;
class GetStateResponse_MetadataEntry_DoNotUse;
struct GetStateResponse_MetadataEntry_DoNotUseDefaultTypeInternal;
extern GetStateResponse_MetadataEntry_DoNotUseDefaultTypeInternal _GetStateResponse_MetadataEntry_DoNotUse_default_instance_;
class HTTPExtension;
struct HTTPExtensionDefaultTypeInternal;
extern HTTPExtensionDefaultTypeInternal _HTTPExtension_default_instance_;
class InvokeBindingRequest;
struct InvokeBindingRequestDefaultTypeInternal;
extern InvokeBindingRequestDefaultTypeInternal _InvokeBindingRequest_default_instance_;
class InvokeBindingRequest_MetadataEntry_DoNotUse;
struct InvokeBindingRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern InvokeBindingRequest_MetadataEntry_DoNotUseDefaultTypeInternal _InvokeBindingRequest_MetadataEntry_DoNotUse_default_instance_;
class InvokeBindingResponse;
struct InvokeBindingResponseDefaultTypeInternal;
extern InvokeBindingResponseDefaultTypeInternal _InvokeBindingResponse_default_instance_;
class InvokeBindingResponse_MetadataEntry_DoNotUse;
struct InvokeBindingResponse_MetadataEntry_DoNotUseDefaultTypeInternal;
extern InvokeBindingResponse_MetadataEntry_DoNotUseDefaultTypeInternal _InvokeBindingResponse_MetadataEntry_DoNotUse_default_instance_;
class InvokeResponse;
struct InvokeResponseDefaultTypeInternal;
extern InvokeResponseDefaultTypeInternal _InvokeResponse_default_instance_;
class InvokeServiceRequest;
struct InvokeServiceRequestDefaultTypeInternal;
extern InvokeServiceRequestDefaultTypeInternal _InvokeServiceRequest_default_instance_;
class ListFileRequest;
struct ListFileRequestDefaultTypeInternal;
extern ListFileRequestDefaultTypeInternal _ListFileRequest_default_instance_;
class ListFileResp;
struct ListFileRespDefaultTypeInternal;
extern ListFileRespDefaultTypeInternal _ListFileResp_default_instance_;
class PublishEventRequest;
struct PublishEventRequestDefaultTypeInternal;
extern PublishEventRequestDefaultTypeInternal _PublishEventRequest_default_instance_;
class PublishEventRequest_MetadataEntry_DoNotUse;
struct PublishEventRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern PublishEventRequest_MetadataEntry_DoNotUseDefaultTypeInternal _PublishEventRequest_MetadataEntry_DoNotUse_default_instance_;
class PutFileRequest;
struct PutFileRequestDefaultTypeInternal;
extern PutFileRequestDefaultTypeInternal _PutFileRequest_default_instance_;
class PutFileRequest_MetadataEntry_DoNotUse;
struct PutFileRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern PutFileRequest_MetadataEntry_DoNotUseDefaultTypeInternal _PutFileRequest_MetadataEntry_DoNotUse_default_instance_;
class SaveConfigurationRequest;
struct SaveConfigurationRequestDefaultTypeInternal;
extern SaveConfigurationRequestDefaultTypeInternal _SaveConfigurationRequest_default_instance_;
class SaveConfigurationRequest_MetadataEntry_DoNotUse;
struct SaveConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SaveConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal _SaveConfigurationRequest_MetadataEntry_DoNotUse_default_instance_;
class SaveStateRequest;
struct SaveStateRequestDefaultTypeInternal;
extern SaveStateRequestDefaultTypeInternal _SaveStateRequest_default_instance_;
class SayHelloRequest;
struct SayHelloRequestDefaultTypeInternal;
extern SayHelloRequestDefaultTypeInternal _SayHelloRequest_default_instance_;
class SayHelloResponse;
struct SayHelloResponseDefaultTypeInternal;
extern SayHelloResponseDefaultTypeInternal _SayHelloResponse_default_instance_;
class SequencerOptions;
struct SequencerOptionsDefaultTypeInternal;
extern SequencerOptionsDefaultTypeInternal _SequencerOptions_default_instance_;
class StateItem;
struct StateItemDefaultTypeInternal;
extern StateItemDefaultTypeInternal _StateItem_default_instance_;
class StateItem_MetadataEntry_DoNotUse;
struct StateItem_MetadataEntry_DoNotUseDefaultTypeInternal;
extern StateItem_MetadataEntry_DoNotUseDefaultTypeInternal _StateItem_MetadataEntry_DoNotUse_default_instance_;
class StateOptions;
struct StateOptionsDefaultTypeInternal;
extern StateOptionsDefaultTypeInternal _StateOptions_default_instance_;
class SubscribeConfigurationRequest;
struct SubscribeConfigurationRequestDefaultTypeInternal;
extern SubscribeConfigurationRequestDefaultTypeInternal _SubscribeConfigurationRequest_default_instance_;
class SubscribeConfigurationRequest_MetadataEntry_DoNotUse;
struct SubscribeConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern SubscribeConfigurationRequest_MetadataEntry_DoNotUseDefaultTypeInternal _SubscribeConfigurationRequest_MetadataEntry_DoNotUse_default_instance_;
class SubscribeConfigurationResponse;
struct SubscribeConfigurationResponseDefaultTypeInternal;
extern SubscribeConfigurationResponseDefaultTypeInternal _SubscribeConfigurationResponse_default_instance_;
class TransactionalStateOperation;
struct TransactionalStateOperationDefaultTypeInternal;
extern TransactionalStateOperationDefaultTypeInternal _TransactionalStateOperation_default_instance_;
class TryLockRequest;
struct TryLockRequestDefaultTypeInternal;
extern TryLockRequestDefaultTypeInternal _TryLockRequest_default_instance_;
class TryLockResponse;
struct TryLockResponseDefaultTypeInternal;
extern TryLockResponseDefaultTypeInternal _TryLockResponse_default_instance_;
class UnlockRequest;
struct UnlockRequestDefaultTypeInternal;
extern UnlockRequestDefaultTypeInternal _UnlockRequest_default_instance_;
class UnlockResponse;
struct UnlockResponseDefaultTypeInternal;
extern UnlockResponseDefaultTypeInternal _UnlockResponse_default_instance_;
}  // namespace v1
}  // namespace runtime
}  // namespace proto
}  // namespace spec
PROTOBUF_NAMESPACE_OPEN
template<> ::spec::proto::runtime::v1::BulkStateItem* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::BulkStateItem>(Arena*);
template<> ::spec::proto::runtime::v1::BulkStateItem_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::BulkStateItem_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::CommonInvokeRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::CommonInvokeRequest>(Arena*);
template<> ::spec::proto::runtime::v1::ConfigurationItem* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ConfigurationItem>(Arena*);
template<> ::spec::proto::runtime::v1::ConfigurationItem_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ConfigurationItem_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::ConfigurationItem_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ConfigurationItem_TagsEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::DelFileRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::DelFileRequest>(Arena*);
template<> ::spec::proto::runtime::v1::DeleteBulkStateRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::DeleteBulkStateRequest>(Arena*);
template<> ::spec::proto::runtime::v1::DeleteConfigurationRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::DeleteConfigurationRequest>(Arena*);
template<> ::spec::proto::runtime::v1::DeleteConfigurationRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::DeleteConfigurationRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::DeleteStateRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::DeleteStateRequest>(Arena*);
template<> ::spec::proto::runtime::v1::DeleteStateRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::DeleteStateRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::Etag* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::Etag>(Arena*);
template<> ::spec::proto::runtime::v1::ExecuteStateTransactionRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ExecuteStateTransactionRequest>(Arena*);
template<> ::spec::proto::runtime::v1::ExecuteStateTransactionRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ExecuteStateTransactionRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::FileInfo* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileInfo>(Arena*);
template<> ::spec::proto::runtime::v1::FileInfo_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileInfo_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::FileMeta* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileMeta>(Arena*);
template<> ::spec::proto::runtime::v1::FileMetaValue* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileMetaValue>(Arena*);
template<> ::spec::proto::runtime::v1::FileMeta_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileMeta_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::FileRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileRequest>(Arena*);
template<> ::spec::proto::runtime::v1::FileRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::FileRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::GetBulkStateRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetBulkStateRequest>(Arena*);
template<> ::spec::proto::runtime::v1::GetBulkStateRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetBulkStateRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::GetBulkStateResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetBulkStateResponse>(Arena*);
template<> ::spec::proto::runtime::v1::GetConfigurationRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetConfigurationRequest>(Arena*);
template<> ::spec::proto::runtime::v1::GetConfigurationRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetConfigurationRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::GetConfigurationResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetConfigurationResponse>(Arena*);
template<> ::spec::proto::runtime::v1::GetFileMetaRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetFileMetaRequest>(Arena*);
template<> ::spec::proto::runtime::v1::GetFileMetaResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetFileMetaResponse>(Arena*);
template<> ::spec::proto::runtime::v1::GetFileRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetFileRequest>(Arena*);
template<> ::spec::proto::runtime::v1::GetFileRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetFileRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::GetFileResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetFileResponse>(Arena*);
template<> ::spec::proto::runtime::v1::GetNextIdRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetNextIdRequest>(Arena*);
template<> ::spec::proto::runtime::v1::GetNextIdRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetNextIdRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::GetNextIdResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetNextIdResponse>(Arena*);
template<> ::spec::proto::runtime::v1::GetStateRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetStateRequest>(Arena*);
template<> ::spec::proto::runtime::v1::GetStateRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetStateRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::GetStateResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetStateResponse>(Arena*);
template<> ::spec::proto::runtime::v1::GetStateResponse_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::GetStateResponse_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::HTTPExtension* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::HTTPExtension>(Arena*);
template<> ::spec::proto::runtime::v1::InvokeBindingRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::InvokeBindingRequest>(Arena*);
template<> ::spec::proto::runtime::v1::InvokeBindingRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::InvokeBindingRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::InvokeBindingResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::InvokeBindingResponse>(Arena*);
template<> ::spec::proto::runtime::v1::InvokeBindingResponse_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::InvokeBindingResponse_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::InvokeResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::InvokeResponse>(Arena*);
template<> ::spec::proto::runtime::v1::InvokeServiceRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::InvokeServiceRequest>(Arena*);
template<> ::spec::proto::runtime::v1::ListFileRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ListFileRequest>(Arena*);
template<> ::spec::proto::runtime::v1::ListFileResp* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::ListFileResp>(Arena*);
template<> ::spec::proto::runtime::v1::PublishEventRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::PublishEventRequest>(Arena*);
template<> ::spec::proto::runtime::v1::PublishEventRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::PublishEventRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::PutFileRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::PutFileRequest>(Arena*);
template<> ::spec::proto::runtime::v1::PutFileRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::PutFileRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::SaveConfigurationRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SaveConfigurationRequest>(Arena*);
template<> ::spec::proto::runtime::v1::SaveConfigurationRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SaveConfigurationRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::SaveStateRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SaveStateRequest>(Arena*);
template<> ::spec::proto::runtime::v1::SayHelloRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SayHelloRequest>(Arena*);
template<> ::spec::proto::runtime::v1::SayHelloResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SayHelloResponse>(Arena*);
template<> ::spec::proto::runtime::v1::SequencerOptions* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SequencerOptions>(Arena*);
template<> ::spec::proto::runtime::v1::StateItem* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::StateItem>(Arena*);
template<> ::spec::proto::runtime::v1::StateItem_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::StateItem_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::StateOptions* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::StateOptions>(Arena*);
template<> ::spec::proto::runtime::v1::SubscribeConfigurationRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SubscribeConfigurationRequest>(Arena*);
template<> ::spec::proto::runtime::v1::SubscribeConfigurationRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SubscribeConfigurationRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::spec::proto::runtime::v1::SubscribeConfigurationResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::SubscribeConfigurationResponse>(Arena*);
template<> ::spec::proto::runtime::v1::TransactionalStateOperation* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::TransactionalStateOperation>(Arena*);
template<> ::spec::proto::runtime::v1::TryLockRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::TryLockRequest>(Arena*);
template<> ::spec::proto::runtime::v1::TryLockResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::TryLockResponse>(Arena*);
template<> ::spec::proto::runtime::v1::UnlockRequest* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::UnlockRequest>(Arena*);
template<> ::spec::proto::runtime::v1::UnlockResponse* Arena::CreateMaybeMessage<::spec::proto::runtime::v1::UnlockResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace spec {
namespace proto {
namespace runtime {
namespace v1 {

enum SequencerOptions_AutoIncrement : int {
  SequencerOptions_AutoIncrement_WEAK = 0,
  SequencerOptions_AutoIncrement_STRONG = 1,
  SequencerOptions_AutoIncrement_SequencerOptions_AutoIncrement_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SequencerOptions_AutoIncrement_SequencerOptions_AutoIncrement_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SequencerOptions_AutoIncrement_IsValid(int value);
constexpr SequencerOptions_AutoIncrement SequencerOptions_AutoIncrement_AutoIncrement_MIN = SequencerOptions_AutoIncrement_WEAK;
constexpr SequencerOptions_AutoIncrement SequencerOptions_AutoIncrement_AutoIncrement_MAX = SequencerOptions_AutoIncrement_STRONG;
constexpr int SequencerOptions_AutoIncrement_AutoIncrement_ARRAYSIZE = SequencerOptions_AutoIncrement_AutoIncrement_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SequencerOptions_AutoIncrement_descriptor();
template<typename T>
inline const std::string& SequencerOptions_AutoIncrement_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SequencerOptions_AutoIncrement>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SequencerOptions_AutoIncrement_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SequencerOptions_AutoIncrement_descriptor(), enum_t_value);
}
inline bool SequencerOptions_AutoIncrement_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SequencerOptions_AutoIncrement* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SequencerOptions_AutoIncrement>(
    SequencerOptions_AutoIncrement_descriptor(), name, value);
}
enum UnlockResponse_Status : int {
  UnlockResponse_Status_SUCCESS = 0,
  UnlockResponse_Status_LOCK_UNEXIST = 1,
  UnlockResponse_Status_LOCK_BELONG_TO_OTHERS = 2,
  UnlockResponse_Status_INTERNAL_ERROR = 3,
  UnlockResponse_Status_UnlockResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UnlockResponse_Status_UnlockResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UnlockResponse_Status_IsValid(int value);
constexpr UnlockResponse_Status UnlockResponse_Status_Status_MIN = UnlockResponse_Status_SUCCESS;
constexpr UnlockResponse_Status UnlockResponse_Status_Status_MAX = UnlockResponse_Status_INTERNAL_ERROR;
constexpr int UnlockResponse_Status_Status_ARRAYSIZE = UnlockResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnlockResponse_Status_descriptor();
template<typename T>
inline const std::string& UnlockResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnlockResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnlockResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UnlockResponse_Status_descriptor(), enum_t_value);
}
inline bool UnlockResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnlockResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnlockResponse_Status>(
    UnlockResponse_Status_descriptor(), name, value);
}
enum HTTPExtension_Verb : int {
  HTTPExtension_Verb_NONE = 0,
  HTTPExtension_Verb_GET = 1,
  HTTPExtension_Verb_HEAD = 2,
  HTTPExtension_Verb_POST = 3,
  HTTPExtension_Verb_PUT = 4,
  HTTPExtension_Verb_DELETE = 5,
  HTTPExtension_Verb_CONNECT = 6,
  HTTPExtension_Verb_OPTIONS = 7,
  HTTPExtension_Verb_TRACE = 8,
  HTTPExtension_Verb_HTTPExtension_Verb_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HTTPExtension_Verb_HTTPExtension_Verb_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HTTPExtension_Verb_IsValid(int value);
constexpr HTTPExtension_Verb HTTPExtension_Verb_Verb_MIN = HTTPExtension_Verb_NONE;
constexpr HTTPExtension_Verb HTTPExtension_Verb_Verb_MAX = HTTPExtension_Verb_TRACE;
constexpr int HTTPExtension_Verb_Verb_ARRAYSIZE = HTTPExtension_Verb_Verb_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HTTPExtension_Verb_descriptor();
template<typename T>
inline const std::string& HTTPExtension_Verb_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HTTPExtension_Verb>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HTTPExtension_Verb_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HTTPExtension_Verb_descriptor(), enum_t_value);
}
inline bool HTTPExtension_Verb_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HTTPExtension_Verb* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HTTPExtension_Verb>(
    HTTPExtension_Verb_descriptor(), name, value);
}
enum StateOptions_StateConcurrency : int {
  StateOptions_StateConcurrency_CONCURRENCY_UNSPECIFIED = 0,
  StateOptions_StateConcurrency_CONCURRENCY_FIRST_WRITE = 1,
  StateOptions_StateConcurrency_CONCURRENCY_LAST_WRITE = 2,
  StateOptions_StateConcurrency_StateOptions_StateConcurrency_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StateOptions_StateConcurrency_StateOptions_StateConcurrency_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StateOptions_StateConcurrency_IsValid(int value);
constexpr StateOptions_StateConcurrency StateOptions_StateConcurrency_StateConcurrency_MIN = StateOptions_StateConcurrency_CONCURRENCY_UNSPECIFIED;
constexpr StateOptions_StateConcurrency StateOptions_StateConcurrency_StateConcurrency_MAX = StateOptions_StateConcurrency_CONCURRENCY_LAST_WRITE;
constexpr int StateOptions_StateConcurrency_StateConcurrency_ARRAYSIZE = StateOptions_StateConcurrency_StateConcurrency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateOptions_StateConcurrency_descriptor();
template<typename T>
inline const std::string& StateOptions_StateConcurrency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StateOptions_StateConcurrency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StateOptions_StateConcurrency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StateOptions_StateConcurrency_descriptor(), enum_t_value);
}
inline bool StateOptions_StateConcurrency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StateOptions_StateConcurrency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateOptions_StateConcurrency>(
    StateOptions_StateConcurrency_descriptor(), name, value);
}
enum StateOptions_StateConsistency : int {
  StateOptions_StateConsistency_CONSISTENCY_UNSPECIFIED = 0,
  StateOptions_StateConsistency_CONSISTENCY_EVENTUAL = 1,
  StateOptions_StateConsistency_CONSISTENCY_STRONG = 2,
  StateOptions_StateConsistency_StateOptions_StateConsistency_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StateOptions_StateConsistency_StateOptions_StateConsistency_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StateOptions_StateConsistency_IsValid(int value);
constexpr StateOptions_StateConsistency StateOptions_StateConsistency_StateConsistency_MIN = StateOptions_StateConsistency_CONSISTENCY_UNSPECIFIED;
constexpr StateOptions_StateConsistency StateOptions_StateConsistency_StateConsistency_MAX = StateOptions_StateConsistency_CONSISTENCY_STRONG;
constexpr int StateOptions_StateConsistency_StateConsistency_ARRAYSIZE = StateOptions_StateConsistency_StateConsistency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateOptions_StateConsistency_descriptor();
template<typename T>
inline const std::string& StateOptions_StateConsistency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StateOptions_StateConsistency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StateOptions_StateConsistency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StateOptions_StateConsistency_descriptor(), enum_t_value);
}
inline bool StateOptions_StateConsistency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StateOptions_StateConsistency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateOptions_StateConsistency>(
    StateOptions_StateConsistency_descriptor(), name, value);
}
// ===================================================================

class GetFileMetaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetFileMetaRequest) */ {
 public:
  inline GetFileMetaRequest() : GetFileMetaRequest(nullptr) {}
  ~GetFileMetaRequest() override;
  explicit constexpr GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaRequest(const GetFileMetaRequest& from);
  GetFileMetaRequest(GetFileMetaRequest&& from) noexcept
    : GetFileMetaRequest() {
    *this = ::std::move(from);
  }

  inline GetFileMetaRequest& operator=(const GetFileMetaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaRequest& operator=(GetFileMetaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaRequest*>(
               &_GetFileMetaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetFileMetaRequest& a, GetFileMetaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetFileMetaRequest";
  }
  protected:
  explicit GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .spec.proto.runtime.v1.FileRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::spec::proto::runtime::v1::FileRequest& request() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::FileRequest* release_request();
  ::spec::proto::runtime::v1::FileRequest* mutable_request();
  void set_allocated_request(::spec::proto::runtime::v1::FileRequest* request);
  private:
  const ::spec::proto::runtime::v1::FileRequest& _internal_request() const;
  ::spec::proto::runtime::v1::FileRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::spec::proto::runtime::v1::FileRequest* request);
  ::spec::proto::runtime::v1::FileRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetFileMetaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::spec::proto::runtime::v1::FileRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetFileMetaResponse) */ {
 public:
  inline GetFileMetaResponse() : GetFileMetaResponse(nullptr) {}
  ~GetFileMetaResponse() override;
  explicit constexpr GetFileMetaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaResponse(const GetFileMetaResponse& from);
  GetFileMetaResponse(GetFileMetaResponse&& from) noexcept
    : GetFileMetaResponse() {
    *this = ::std::move(from);
  }

  inline GetFileMetaResponse& operator=(const GetFileMetaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaResponse& operator=(GetFileMetaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaResponse* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaResponse*>(
               &_GetFileMetaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetFileMetaResponse& a, GetFileMetaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetFileMetaResponse";
  }
  protected:
  explicit GetFileMetaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastModifiedFieldNumber = 2,
    kResponseFieldNumber = 3,
    kSizeFieldNumber = 1,
  };
  // string last_modified = 2;
  void clear_last_modified();
  const std::string& last_modified() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_modified(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_modified();
  PROTOBUF_NODISCARD std::string* release_last_modified();
  void set_allocated_last_modified(std::string* last_modified);
  private:
  const std::string& _internal_last_modified() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_modified(const std::string& value);
  std::string* _internal_mutable_last_modified();
  public:

  // .spec.proto.runtime.v1.FileMeta response = 3;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::spec::proto::runtime::v1::FileMeta& response() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::FileMeta* release_response();
  ::spec::proto::runtime::v1::FileMeta* mutable_response();
  void set_allocated_response(::spec::proto::runtime::v1::FileMeta* response);
  private:
  const ::spec::proto::runtime::v1::FileMeta& _internal_response() const;
  ::spec::proto::runtime::v1::FileMeta* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::spec::proto::runtime::v1::FileMeta* response);
  ::spec::proto::runtime::v1::FileMeta* unsafe_arena_release_response();

  // int64 size = 1;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetFileMetaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_modified_;
  ::spec::proto::runtime::v1::FileMeta* response_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class FileMetaValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.FileMetaValue) */ {
 public:
  inline FileMetaValue() : FileMetaValue(nullptr) {}
  ~FileMetaValue() override;
  explicit constexpr FileMetaValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileMetaValue(const FileMetaValue& from);
  FileMetaValue(FileMetaValue&& from) noexcept
    : FileMetaValue() {
    *this = ::std::move(from);
  }

  inline FileMetaValue& operator=(const FileMetaValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMetaValue& operator=(FileMetaValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileMetaValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMetaValue* internal_default_instance() {
    return reinterpret_cast<const FileMetaValue*>(
               &_FileMetaValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileMetaValue& a, FileMetaValue& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMetaValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMetaValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMetaValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileMetaValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileMetaValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileMetaValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileMetaValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.FileMetaValue";
  }
  protected:
  explicit FileMetaValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.FileMetaValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class FileMeta_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FileMeta_MetadataEntry_DoNotUse, 
    std::string, ::spec::proto::runtime::v1::FileMetaValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FileMeta_MetadataEntry_DoNotUse, 
    std::string, ::spec::proto::runtime::v1::FileMetaValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  FileMeta_MetadataEntry_DoNotUse();
  explicit constexpr FileMeta_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FileMeta_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FileMeta_MetadataEntry_DoNotUse& other);
  static const FileMeta_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FileMeta_MetadataEntry_DoNotUse*>(&_FileMeta_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.FileMeta.MetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class FileMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.FileMeta) */ {
 public:
  inline FileMeta() : FileMeta(nullptr) {}
  ~FileMeta() override;
  explicit constexpr FileMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileMeta(const FileMeta& from);
  FileMeta(FileMeta&& from) noexcept
    : FileMeta() {
    *this = ::std::move(from);
  }

  inline FileMeta& operator=(const FileMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMeta& operator=(FileMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMeta* internal_default_instance() {
    return reinterpret_cast<const FileMeta*>(
               &_FileMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FileMeta& a, FileMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.FileMeta";
  }
  protected:
  explicit FileMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // map<string, .spec.proto.runtime.v1.FileMetaValue> metadata = 1;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >*
      mutable_metadata();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.FileMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      FileMeta_MetadataEntry_DoNotUse,
      std::string, ::spec::proto::runtime::v1::FileMetaValue,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetFileRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFileRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFileRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetFileRequest_MetadataEntry_DoNotUse();
  explicit constexpr GetFileRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetFileRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFileRequest_MetadataEntry_DoNotUse& other);
  static const GetFileRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFileRequest_MetadataEntry_DoNotUse*>(&_GetFileRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetFileRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetFileRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetFileRequest) */ {
 public:
  inline GetFileRequest() : GetFileRequest(nullptr) {}
  ~GetFileRequest() override;
  explicit constexpr GetFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileRequest(const GetFileRequest& from);
  GetFileRequest(GetFileRequest&& from) noexcept
    : GetFileRequest() {
    *this = ::std::move(from);
  }

  inline GetFileRequest& operator=(const GetFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileRequest& operator=(GetFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileRequest*>(
               &_GetFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetFileRequest& a, GetFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetFileRequest";
  }
  protected:
  explicit GetFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kStoreNameFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetFileRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetFileResponse) */ {
 public:
  inline GetFileResponse() : GetFileResponse(nullptr) {}
  ~GetFileResponse() override;
  explicit constexpr GetFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileResponse(const GetFileResponse& from);
  GetFileResponse(GetFileResponse&& from) noexcept
    : GetFileResponse() {
    *this = ::std::move(from);
  }

  inline GetFileResponse& operator=(const GetFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileResponse& operator=(GetFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileResponse* internal_default_instance() {
    return reinterpret_cast<const GetFileResponse*>(
               &_GetFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetFileResponse& a, GetFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetFileResponse";
  }
  protected:
  explicit GetFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class PutFileRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PutFileRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PutFileRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PutFileRequest_MetadataEntry_DoNotUse();
  explicit constexpr PutFileRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PutFileRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PutFileRequest_MetadataEntry_DoNotUse& other);
  static const PutFileRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PutFileRequest_MetadataEntry_DoNotUse*>(&_PutFileRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.PutFileRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.PutFileRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class PutFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.PutFileRequest) */ {
 public:
  inline PutFileRequest() : PutFileRequest(nullptr) {}
  ~PutFileRequest() override;
  explicit constexpr PutFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutFileRequest(const PutFileRequest& from);
  PutFileRequest(PutFileRequest&& from) noexcept
    : PutFileRequest() {
    *this = ::std::move(from);
  }

  inline PutFileRequest& operator=(const PutFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutFileRequest& operator=(PutFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutFileRequest* internal_default_instance() {
    return reinterpret_cast<const PutFileRequest*>(
               &_PutFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PutFileRequest& a, PutFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PutFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.PutFileRequest";
  }
  protected:
  explicit PutFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 4,
    kStoreNameFieldNumber = 1,
    kNameFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.PutFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PutFileRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class FileRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FileRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FileRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  FileRequest_MetadataEntry_DoNotUse();
  explicit constexpr FileRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FileRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FileRequest_MetadataEntry_DoNotUse& other);
  static const FileRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FileRequest_MetadataEntry_DoNotUse*>(&_FileRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.FileRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.FileRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class FileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.FileRequest) */ {
 public:
  inline FileRequest() : FileRequest(nullptr) {}
  ~FileRequest() override;
  explicit constexpr FileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileRequest(const FileRequest& from);
  FileRequest(FileRequest&& from) noexcept
    : FileRequest() {
    *this = ::std::move(from);
  }

  inline FileRequest& operator=(const FileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileRequest& operator=(FileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileRequest* internal_default_instance() {
    return reinterpret_cast<const FileRequest*>(
               &_FileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FileRequest& a, FileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.FileRequest";
  }
  protected:
  explicit FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kStoreNameFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.FileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      FileRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class ListFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.ListFileRequest) */ {
 public:
  inline ListFileRequest() : ListFileRequest(nullptr) {}
  ~ListFileRequest() override;
  explicit constexpr ListFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFileRequest(const ListFileRequest& from);
  ListFileRequest(ListFileRequest&& from) noexcept
    : ListFileRequest() {
    *this = ::std::move(from);
  }

  inline ListFileRequest& operator=(const ListFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFileRequest& operator=(ListFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFileRequest* internal_default_instance() {
    return reinterpret_cast<const ListFileRequest*>(
               &_ListFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListFileRequest& a, ListFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.ListFileRequest";
  }
  protected:
  explicit ListFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarkerFieldNumber = 3,
    kRequestFieldNumber = 1,
    kPageSizeFieldNumber = 2,
  };
  // string marker = 3;
  void clear_marker();
  const std::string& marker() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marker(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marker();
  PROTOBUF_NODISCARD std::string* release_marker();
  void set_allocated_marker(std::string* marker);
  private:
  const std::string& _internal_marker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marker(const std::string& value);
  std::string* _internal_mutable_marker();
  public:

  // .spec.proto.runtime.v1.FileRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::spec::proto::runtime::v1::FileRequest& request() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::FileRequest* release_request();
  ::spec::proto::runtime::v1::FileRequest* mutable_request();
  void set_allocated_request(::spec::proto::runtime::v1::FileRequest* request);
  private:
  const ::spec::proto::runtime::v1::FileRequest& _internal_request() const;
  ::spec::proto::runtime::v1::FileRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::spec::proto::runtime::v1::FileRequest* request);
  ::spec::proto::runtime::v1::FileRequest* unsafe_arena_release_request();

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.ListFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marker_;
  ::spec::proto::runtime::v1::FileRequest* request_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class FileInfo_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FileInfo_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FileInfo_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  FileInfo_MetadataEntry_DoNotUse();
  explicit constexpr FileInfo_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FileInfo_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FileInfo_MetadataEntry_DoNotUse& other);
  static const FileInfo_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FileInfo_MetadataEntry_DoNotUse*>(&_FileInfo_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.FileInfo.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.FileInfo.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class FileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() override;
  explicit constexpr FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 4,
    kFileNameFieldNumber = 1,
    kLastModifiedFieldNumber = 3,
    kSizeFieldNumber = 2,
  };
  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string last_modified = 3;
  void clear_last_modified();
  const std::string& last_modified() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_modified(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_modified();
  PROTOBUF_NODISCARD std::string* release_last_modified();
  void set_allocated_last_modified(std::string* last_modified);
  private:
  const std::string& _internal_last_modified() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_modified(const std::string& value);
  std::string* _internal_mutable_last_modified();
  public:

  // int64 size = 2;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.FileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      FileInfo_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_modified_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class ListFileResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.ListFileResp) */ {
 public:
  inline ListFileResp() : ListFileResp(nullptr) {}
  ~ListFileResp() override;
  explicit constexpr ListFileResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFileResp(const ListFileResp& from);
  ListFileResp(ListFileResp&& from) noexcept
    : ListFileResp() {
    *this = ::std::move(from);
  }

  inline ListFileResp& operator=(const ListFileResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFileResp& operator=(ListFileResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFileResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFileResp* internal_default_instance() {
    return reinterpret_cast<const ListFileResp*>(
               &_ListFileResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListFileResp& a, ListFileResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFileResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFileResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFileResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFileResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFileResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFileResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFileResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.ListFileResp";
  }
  protected:
  explicit ListFileResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
    kMarkerFieldNumber = 2,
    kIsTruncatedFieldNumber = 3,
  };
  // repeated .spec.proto.runtime.v1.FileInfo files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::spec::proto::runtime::v1::FileInfo* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::FileInfo >*
      mutable_files();
  private:
  const ::spec::proto::runtime::v1::FileInfo& _internal_files(int index) const;
  ::spec::proto::runtime::v1::FileInfo* _internal_add_files();
  public:
  const ::spec::proto::runtime::v1::FileInfo& files(int index) const;
  ::spec::proto::runtime::v1::FileInfo* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::FileInfo >&
      files() const;

  // string marker = 2;
  void clear_marker();
  const std::string& marker() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_marker(ArgT0&& arg0, ArgT... args);
  std::string* mutable_marker();
  PROTOBUF_NODISCARD std::string* release_marker();
  void set_allocated_marker(std::string* marker);
  private:
  const std::string& _internal_marker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marker(const std::string& value);
  std::string* _internal_mutable_marker();
  public:

  // bool is_truncated = 3;
  void clear_is_truncated();
  bool is_truncated() const;
  void set_is_truncated(bool value);
  private:
  bool _internal_is_truncated() const;
  void _internal_set_is_truncated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.ListFileResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::FileInfo > files_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marker_;
  bool is_truncated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class DelFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.DelFileRequest) */ {
 public:
  inline DelFileRequest() : DelFileRequest(nullptr) {}
  ~DelFileRequest() override;
  explicit constexpr DelFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelFileRequest(const DelFileRequest& from);
  DelFileRequest(DelFileRequest&& from) noexcept
    : DelFileRequest() {
    *this = ::std::move(from);
  }

  inline DelFileRequest& operator=(const DelFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelFileRequest& operator=(DelFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelFileRequest* internal_default_instance() {
    return reinterpret_cast<const DelFileRequest*>(
               &_DelFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DelFileRequest& a, DelFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DelFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.DelFileRequest";
  }
  protected:
  explicit DelFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .spec.proto.runtime.v1.FileRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::spec::proto::runtime::v1::FileRequest& request() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::FileRequest* release_request();
  ::spec::proto::runtime::v1::FileRequest* mutable_request();
  void set_allocated_request(::spec::proto::runtime::v1::FileRequest* request);
  private:
  const ::spec::proto::runtime::v1::FileRequest& _internal_request() const;
  ::spec::proto::runtime::v1::FileRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::spec::proto::runtime::v1::FileRequest* request);
  ::spec::proto::runtime::v1::FileRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.DelFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::spec::proto::runtime::v1::FileRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetNextIdRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetNextIdRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetNextIdRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetNextIdRequest_MetadataEntry_DoNotUse();
  explicit constexpr GetNextIdRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetNextIdRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetNextIdRequest_MetadataEntry_DoNotUse& other);
  static const GetNextIdRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetNextIdRequest_MetadataEntry_DoNotUse*>(&_GetNextIdRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetNextIdRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetNextIdRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetNextIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetNextIdRequest) */ {
 public:
  inline GetNextIdRequest() : GetNextIdRequest(nullptr) {}
  ~GetNextIdRequest() override;
  explicit constexpr GetNextIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNextIdRequest(const GetNextIdRequest& from);
  GetNextIdRequest(GetNextIdRequest&& from) noexcept
    : GetNextIdRequest() {
    *this = ::std::move(from);
  }

  inline GetNextIdRequest& operator=(const GetNextIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNextIdRequest& operator=(GetNextIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNextIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNextIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetNextIdRequest*>(
               &_GetNextIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetNextIdRequest& a, GetNextIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNextIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNextIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNextIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNextIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNextIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNextIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetNextIdRequest";
  }
  protected:
  explicit GetNextIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 4,
    kStoreNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .spec.proto.runtime.v1.SequencerOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::spec::proto::runtime::v1::SequencerOptions& options() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::SequencerOptions* release_options();
  ::spec::proto::runtime::v1::SequencerOptions* mutable_options();
  void set_allocated_options(::spec::proto::runtime::v1::SequencerOptions* options);
  private:
  const ::spec::proto::runtime::v1::SequencerOptions& _internal_options() const;
  ::spec::proto::runtime::v1::SequencerOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::spec::proto::runtime::v1::SequencerOptions* options);
  ::spec::proto::runtime::v1::SequencerOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetNextIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetNextIdRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::spec::proto::runtime::v1::SequencerOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SequencerOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SequencerOptions) */ {
 public:
  inline SequencerOptions() : SequencerOptions(nullptr) {}
  ~SequencerOptions() override;
  explicit constexpr SequencerOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequencerOptions(const SequencerOptions& from);
  SequencerOptions(SequencerOptions&& from) noexcept
    : SequencerOptions() {
    *this = ::std::move(from);
  }

  inline SequencerOptions& operator=(const SequencerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequencerOptions& operator=(SequencerOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SequencerOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SequencerOptions* internal_default_instance() {
    return reinterpret_cast<const SequencerOptions*>(
               &_SequencerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SequencerOptions& a, SequencerOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SequencerOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequencerOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SequencerOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SequencerOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SequencerOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SequencerOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequencerOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SequencerOptions";
  }
  protected:
  explicit SequencerOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SequencerOptions_AutoIncrement AutoIncrement;
  static constexpr AutoIncrement WEAK =
    SequencerOptions_AutoIncrement_WEAK;
  static constexpr AutoIncrement STRONG =
    SequencerOptions_AutoIncrement_STRONG;
  static inline bool AutoIncrement_IsValid(int value) {
    return SequencerOptions_AutoIncrement_IsValid(value);
  }
  static constexpr AutoIncrement AutoIncrement_MIN =
    SequencerOptions_AutoIncrement_AutoIncrement_MIN;
  static constexpr AutoIncrement AutoIncrement_MAX =
    SequencerOptions_AutoIncrement_AutoIncrement_MAX;
  static constexpr int AutoIncrement_ARRAYSIZE =
    SequencerOptions_AutoIncrement_AutoIncrement_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AutoIncrement_descriptor() {
    return SequencerOptions_AutoIncrement_descriptor();
  }
  template<typename T>
  static inline const std::string& AutoIncrement_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AutoIncrement>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AutoIncrement_Name.");
    return SequencerOptions_AutoIncrement_Name(enum_t_value);
  }
  static inline bool AutoIncrement_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AutoIncrement* value) {
    return SequencerOptions_AutoIncrement_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIncrementFieldNumber = 1,
  };
  // .spec.proto.runtime.v1.SequencerOptions.AutoIncrement increment = 1;
  void clear_increment();
  ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement increment() const;
  void set_increment(::spec::proto::runtime::v1::SequencerOptions_AutoIncrement value);
  private:
  ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement _internal_increment() const;
  void _internal_set_increment(::spec::proto::runtime::v1::SequencerOptions_AutoIncrement value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SequencerOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int increment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetNextIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetNextIdResponse) */ {
 public:
  inline GetNextIdResponse() : GetNextIdResponse(nullptr) {}
  ~GetNextIdResponse() override;
  explicit constexpr GetNextIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNextIdResponse(const GetNextIdResponse& from);
  GetNextIdResponse(GetNextIdResponse&& from) noexcept
    : GetNextIdResponse() {
    *this = ::std::move(from);
  }

  inline GetNextIdResponse& operator=(const GetNextIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNextIdResponse& operator=(GetNextIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNextIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNextIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetNextIdResponse*>(
               &_GetNextIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetNextIdResponse& a, GetNextIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNextIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNextIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNextIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNextIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNextIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNextIdResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextIdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetNextIdResponse";
  }
  protected:
  explicit GetNextIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextIdFieldNumber = 1,
  };
  // int64 next_id = 1;
  void clear_next_id();
  int64_t next_id() const;
  void set_next_id(int64_t value);
  private:
  int64_t _internal_next_id() const;
  void _internal_set_next_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetNextIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t next_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class TryLockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.TryLockRequest) */ {
 public:
  inline TryLockRequest() : TryLockRequest(nullptr) {}
  ~TryLockRequest() override;
  explicit constexpr TryLockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TryLockRequest(const TryLockRequest& from);
  TryLockRequest(TryLockRequest&& from) noexcept
    : TryLockRequest() {
    *this = ::std::move(from);
  }

  inline TryLockRequest& operator=(const TryLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryLockRequest& operator=(TryLockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TryLockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TryLockRequest* internal_default_instance() {
    return reinterpret_cast<const TryLockRequest*>(
               &_TryLockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TryLockRequest& a, TryLockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TryLockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TryLockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TryLockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TryLockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TryLockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TryLockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryLockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.TryLockRequest";
  }
  protected:
  explicit TryLockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreNameFieldNumber = 1,
    kResourceIdFieldNumber = 2,
    kLockOwnerFieldNumber = 3,
    kExpireFieldNumber = 4,
  };
  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string resource_id = 2;
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string lock_owner = 3;
  void clear_lock_owner();
  const std::string& lock_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lock_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lock_owner();
  PROTOBUF_NODISCARD std::string* release_lock_owner();
  void set_allocated_lock_owner(std::string* lock_owner);
  private:
  const std::string& _internal_lock_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lock_owner(const std::string& value);
  std::string* _internal_mutable_lock_owner();
  public:

  // int32 expire = 4;
  void clear_expire();
  int32_t expire() const;
  void set_expire(int32_t value);
  private:
  int32_t _internal_expire() const;
  void _internal_set_expire(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.TryLockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lock_owner_;
  int32_t expire_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class TryLockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.TryLockResponse) */ {
 public:
  inline TryLockResponse() : TryLockResponse(nullptr) {}
  ~TryLockResponse() override;
  explicit constexpr TryLockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TryLockResponse(const TryLockResponse& from);
  TryLockResponse(TryLockResponse&& from) noexcept
    : TryLockResponse() {
    *this = ::std::move(from);
  }

  inline TryLockResponse& operator=(const TryLockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryLockResponse& operator=(TryLockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TryLockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TryLockResponse* internal_default_instance() {
    return reinterpret_cast<const TryLockResponse*>(
               &_TryLockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TryLockResponse& a, TryLockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TryLockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TryLockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TryLockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TryLockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TryLockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TryLockResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TryLockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.TryLockResponse";
  }
  protected:
  explicit TryLockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.TryLockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class UnlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.UnlockRequest) */ {
 public:
  inline UnlockRequest() : UnlockRequest(nullptr) {}
  ~UnlockRequest() override;
  explicit constexpr UnlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockRequest(const UnlockRequest& from);
  UnlockRequest(UnlockRequest&& from) noexcept
    : UnlockRequest() {
    *this = ::std::move(from);
  }

  inline UnlockRequest& operator=(const UnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockRequest& operator=(UnlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockRequest*>(
               &_UnlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UnlockRequest& a, UnlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.UnlockRequest";
  }
  protected:
  explicit UnlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreNameFieldNumber = 1,
    kResourceIdFieldNumber = 2,
    kLockOwnerFieldNumber = 3,
  };
  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string resource_id = 2;
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string lock_owner = 3;
  void clear_lock_owner();
  const std::string& lock_owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lock_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lock_owner();
  PROTOBUF_NODISCARD std::string* release_lock_owner();
  void set_allocated_lock_owner(std::string* lock_owner);
  private:
  const std::string& _internal_lock_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lock_owner(const std::string& value);
  std::string* _internal_mutable_lock_owner();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.UnlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lock_owner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class UnlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.UnlockResponse) */ {
 public:
  inline UnlockResponse() : UnlockResponse(nullptr) {}
  ~UnlockResponse() override;
  explicit constexpr UnlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockResponse(const UnlockResponse& from);
  UnlockResponse(UnlockResponse&& from) noexcept
    : UnlockResponse() {
    *this = ::std::move(from);
  }

  inline UnlockResponse& operator=(const UnlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockResponse& operator=(UnlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockResponse* internal_default_instance() {
    return reinterpret_cast<const UnlockResponse*>(
               &_UnlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UnlockResponse& a, UnlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnlockResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.UnlockResponse";
  }
  protected:
  explicit UnlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UnlockResponse_Status Status;
  static constexpr Status SUCCESS =
    UnlockResponse_Status_SUCCESS;
  static constexpr Status LOCK_UNEXIST =
    UnlockResponse_Status_LOCK_UNEXIST;
  static constexpr Status LOCK_BELONG_TO_OTHERS =
    UnlockResponse_Status_LOCK_BELONG_TO_OTHERS;
  static constexpr Status INTERNAL_ERROR =
    UnlockResponse_Status_INTERNAL_ERROR;
  static inline bool Status_IsValid(int value) {
    return UnlockResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    UnlockResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    UnlockResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    UnlockResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return UnlockResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return UnlockResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return UnlockResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .spec.proto.runtime.v1.UnlockResponse.Status status = 1;
  void clear_status();
  ::spec::proto::runtime::v1::UnlockResponse_Status status() const;
  void set_status(::spec::proto::runtime::v1::UnlockResponse_Status value);
  private:
  ::spec::proto::runtime::v1::UnlockResponse_Status _internal_status() const;
  void _internal_set_status(::spec::proto::runtime::v1::UnlockResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.UnlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SayHelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SayHelloRequest) */ {
 public:
  inline SayHelloRequest() : SayHelloRequest(nullptr) {}
  ~SayHelloRequest() override;
  explicit constexpr SayHelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SayHelloRequest(const SayHelloRequest& from);
  SayHelloRequest(SayHelloRequest&& from) noexcept
    : SayHelloRequest() {
    *this = ::std::move(from);
  }

  inline SayHelloRequest& operator=(const SayHelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SayHelloRequest& operator=(SayHelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SayHelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SayHelloRequest* internal_default_instance() {
    return reinterpret_cast<const SayHelloRequest*>(
               &_SayHelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SayHelloRequest& a, SayHelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SayHelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SayHelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SayHelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SayHelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SayHelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SayHelloRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SayHelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SayHelloRequest";
  }
  protected:
  explicit SayHelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kNameFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Any data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Any* data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SayHelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Any* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SayHelloResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SayHelloResponse) */ {
 public:
  inline SayHelloResponse() : SayHelloResponse(nullptr) {}
  ~SayHelloResponse() override;
  explicit constexpr SayHelloResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SayHelloResponse(const SayHelloResponse& from);
  SayHelloResponse(SayHelloResponse&& from) noexcept
    : SayHelloResponse() {
    *this = ::std::move(from);
  }

  inline SayHelloResponse& operator=(const SayHelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SayHelloResponse& operator=(SayHelloResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SayHelloResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SayHelloResponse* internal_default_instance() {
    return reinterpret_cast<const SayHelloResponse*>(
               &_SayHelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SayHelloResponse& a, SayHelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SayHelloResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SayHelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SayHelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SayHelloResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SayHelloResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SayHelloResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SayHelloResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SayHelloResponse";
  }
  protected:
  explicit SayHelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHelloFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string hello = 1;
  void clear_hello();
  const std::string& hello() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hello(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hello();
  PROTOBUF_NODISCARD std::string* release_hello();
  void set_allocated_hello(std::string* hello);
  private:
  const std::string& _internal_hello() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hello(const std::string& value);
  std::string* _internal_mutable_hello();
  public:

  // .google.protobuf.Any data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Any* data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SayHelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hello_;
  ::PROTOBUF_NAMESPACE_ID::Any* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class InvokeServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.InvokeServiceRequest) */ {
 public:
  inline InvokeServiceRequest() : InvokeServiceRequest(nullptr) {}
  ~InvokeServiceRequest() override;
  explicit constexpr InvokeServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeServiceRequest(const InvokeServiceRequest& from);
  InvokeServiceRequest(InvokeServiceRequest&& from) noexcept
    : InvokeServiceRequest() {
    *this = ::std::move(from);
  }

  inline InvokeServiceRequest& operator=(const InvokeServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeServiceRequest& operator=(InvokeServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeServiceRequest* internal_default_instance() {
    return reinterpret_cast<const InvokeServiceRequest*>(
               &_InvokeServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(InvokeServiceRequest& a, InvokeServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeServiceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.InvokeServiceRequest";
  }
  protected:
  explicit InvokeServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .spec.proto.runtime.v1.CommonInvokeRequest message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::spec::proto::runtime::v1::CommonInvokeRequest& message() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::CommonInvokeRequest* release_message();
  ::spec::proto::runtime::v1::CommonInvokeRequest* mutable_message();
  void set_allocated_message(::spec::proto::runtime::v1::CommonInvokeRequest* message);
  private:
  const ::spec::proto::runtime::v1::CommonInvokeRequest& _internal_message() const;
  ::spec::proto::runtime::v1::CommonInvokeRequest* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::spec::proto::runtime::v1::CommonInvokeRequest* message);
  ::spec::proto::runtime::v1::CommonInvokeRequest* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.InvokeServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::spec::proto::runtime::v1::CommonInvokeRequest* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class CommonInvokeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.CommonInvokeRequest) */ {
 public:
  inline CommonInvokeRequest() : CommonInvokeRequest(nullptr) {}
  ~CommonInvokeRequest() override;
  explicit constexpr CommonInvokeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonInvokeRequest(const CommonInvokeRequest& from);
  CommonInvokeRequest(CommonInvokeRequest&& from) noexcept
    : CommonInvokeRequest() {
    *this = ::std::move(from);
  }

  inline CommonInvokeRequest& operator=(const CommonInvokeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonInvokeRequest& operator=(CommonInvokeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonInvokeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonInvokeRequest* internal_default_instance() {
    return reinterpret_cast<const CommonInvokeRequest*>(
               &_CommonInvokeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CommonInvokeRequest& a, CommonInvokeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonInvokeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonInvokeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonInvokeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonInvokeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonInvokeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommonInvokeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonInvokeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.CommonInvokeRequest";
  }
  protected:
  explicit CommonInvokeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kContentTypeFieldNumber = 3,
    kDataFieldNumber = 2,
    kHttpExtensionFieldNumber = 4,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string content_type = 3;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // .google.protobuf.Any data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Any* data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_data();

  // .spec.proto.runtime.v1.HTTPExtension http_extension = 4;
  bool has_http_extension() const;
  private:
  bool _internal_has_http_extension() const;
  public:
  void clear_http_extension();
  const ::spec::proto::runtime::v1::HTTPExtension& http_extension() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::HTTPExtension* release_http_extension();
  ::spec::proto::runtime::v1::HTTPExtension* mutable_http_extension();
  void set_allocated_http_extension(::spec::proto::runtime::v1::HTTPExtension* http_extension);
  private:
  const ::spec::proto::runtime::v1::HTTPExtension& _internal_http_extension() const;
  ::spec::proto::runtime::v1::HTTPExtension* _internal_mutable_http_extension();
  public:
  void unsafe_arena_set_allocated_http_extension(
      ::spec::proto::runtime::v1::HTTPExtension* http_extension);
  ::spec::proto::runtime::v1::HTTPExtension* unsafe_arena_release_http_extension();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.CommonInvokeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
  ::PROTOBUF_NAMESPACE_ID::Any* data_;
  ::spec::proto::runtime::v1::HTTPExtension* http_extension_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class HTTPExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.HTTPExtension) */ {
 public:
  inline HTTPExtension() : HTTPExtension(nullptr) {}
  ~HTTPExtension() override;
  explicit constexpr HTTPExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HTTPExtension(const HTTPExtension& from);
  HTTPExtension(HTTPExtension&& from) noexcept
    : HTTPExtension() {
    *this = ::std::move(from);
  }

  inline HTTPExtension& operator=(const HTTPExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline HTTPExtension& operator=(HTTPExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HTTPExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const HTTPExtension* internal_default_instance() {
    return reinterpret_cast<const HTTPExtension*>(
               &_HTTPExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(HTTPExtension& a, HTTPExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(HTTPExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HTTPExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HTTPExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HTTPExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HTTPExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HTTPExtension& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HTTPExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.HTTPExtension";
  }
  protected:
  explicit HTTPExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HTTPExtension_Verb Verb;
  static constexpr Verb NONE =
    HTTPExtension_Verb_NONE;
  static constexpr Verb GET =
    HTTPExtension_Verb_GET;
  static constexpr Verb HEAD =
    HTTPExtension_Verb_HEAD;
  static constexpr Verb POST =
    HTTPExtension_Verb_POST;
  static constexpr Verb PUT =
    HTTPExtension_Verb_PUT;
  static constexpr Verb DELETE =
    HTTPExtension_Verb_DELETE;
  static constexpr Verb CONNECT =
    HTTPExtension_Verb_CONNECT;
  static constexpr Verb OPTIONS =
    HTTPExtension_Verb_OPTIONS;
  static constexpr Verb TRACE =
    HTTPExtension_Verb_TRACE;
  static inline bool Verb_IsValid(int value) {
    return HTTPExtension_Verb_IsValid(value);
  }
  static constexpr Verb Verb_MIN =
    HTTPExtension_Verb_Verb_MIN;
  static constexpr Verb Verb_MAX =
    HTTPExtension_Verb_Verb_MAX;
  static constexpr int Verb_ARRAYSIZE =
    HTTPExtension_Verb_Verb_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Verb_descriptor() {
    return HTTPExtension_Verb_descriptor();
  }
  template<typename T>
  static inline const std::string& Verb_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Verb>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Verb_Name.");
    return HTTPExtension_Verb_Name(enum_t_value);
  }
  static inline bool Verb_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Verb* value) {
    return HTTPExtension_Verb_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kQuerystringFieldNumber = 2,
    kVerbFieldNumber = 1,
  };
  // string querystring = 2;
  void clear_querystring();
  const std::string& querystring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_querystring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_querystring();
  PROTOBUF_NODISCARD std::string* release_querystring();
  void set_allocated_querystring(std::string* querystring);
  private:
  const std::string& _internal_querystring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_querystring(const std::string& value);
  std::string* _internal_mutable_querystring();
  public:

  // .spec.proto.runtime.v1.HTTPExtension.Verb verb = 1;
  void clear_verb();
  ::spec::proto::runtime::v1::HTTPExtension_Verb verb() const;
  void set_verb(::spec::proto::runtime::v1::HTTPExtension_Verb value);
  private:
  ::spec::proto::runtime::v1::HTTPExtension_Verb _internal_verb() const;
  void _internal_set_verb(::spec::proto::runtime::v1::HTTPExtension_Verb value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.HTTPExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr querystring_;
  int verb_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class InvokeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.InvokeResponse) */ {
 public:
  inline InvokeResponse() : InvokeResponse(nullptr) {}
  ~InvokeResponse() override;
  explicit constexpr InvokeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeResponse(const InvokeResponse& from);
  InvokeResponse(InvokeResponse&& from) noexcept
    : InvokeResponse() {
    *this = ::std::move(from);
  }

  inline InvokeResponse& operator=(const InvokeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeResponse& operator=(InvokeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeResponse* internal_default_instance() {
    return reinterpret_cast<const InvokeResponse*>(
               &_InvokeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(InvokeResponse& a, InvokeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.InvokeResponse";
  }
  protected:
  explicit InvokeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentTypeFieldNumber = 2,
    kDataFieldNumber = 1,
  };
  // string content_type = 2;
  void clear_content_type();
  const std::string& content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_type();
  PROTOBUF_NODISCARD std::string* release_content_type();
  void set_allocated_content_type(std::string* content_type);
  private:
  const std::string& _internal_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
  std::string* _internal_mutable_content_type();
  public:

  // .google.protobuf.Any data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Any* data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.InvokeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
  ::PROTOBUF_NAMESPACE_ID::Any* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class ConfigurationItem_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConfigurationItem_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConfigurationItem_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ConfigurationItem_TagsEntry_DoNotUse();
  explicit constexpr ConfigurationItem_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ConfigurationItem_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ConfigurationItem_TagsEntry_DoNotUse& other);
  static const ConfigurationItem_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ConfigurationItem_TagsEntry_DoNotUse*>(&_ConfigurationItem_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.ConfigurationItem.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.ConfigurationItem.TagsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ConfigurationItem_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConfigurationItem_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConfigurationItem_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ConfigurationItem_MetadataEntry_DoNotUse();
  explicit constexpr ConfigurationItem_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ConfigurationItem_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ConfigurationItem_MetadataEntry_DoNotUse& other);
  static const ConfigurationItem_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ConfigurationItem_MetadataEntry_DoNotUse*>(&_ConfigurationItem_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.ConfigurationItem.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.ConfigurationItem.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ConfigurationItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.ConfigurationItem) */ {
 public:
  inline ConfigurationItem() : ConfigurationItem(nullptr) {}
  ~ConfigurationItem() override;
  explicit constexpr ConfigurationItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationItem(const ConfigurationItem& from);
  ConfigurationItem(ConfigurationItem&& from) noexcept
    : ConfigurationItem() {
    *this = ::std::move(from);
  }

  inline ConfigurationItem& operator=(const ConfigurationItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationItem& operator=(ConfigurationItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigurationItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationItem* internal_default_instance() {
    return reinterpret_cast<const ConfigurationItem*>(
               &_ConfigurationItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ConfigurationItem& a, ConfigurationItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigurationItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigurationItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigurationItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.ConfigurationItem";
  }
  protected:
  explicit ConfigurationItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kKeyFieldNumber = 1,
    kContentFieldNumber = 2,
    kGroupFieldNumber = 3,
    kLabelFieldNumber = 4,
  };
  // map<string, string> tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string group = 3;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string label = 4;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.ConfigurationItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ConfigurationItem_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ConfigurationItem_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetConfigurationRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetConfigurationRequest_MetadataEntry_DoNotUse();
  explicit constexpr GetConfigurationRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetConfigurationRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetConfigurationRequest_MetadataEntry_DoNotUse& other);
  static const GetConfigurationRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetConfigurationRequest_MetadataEntry_DoNotUse*>(&_GetConfigurationRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetConfigurationRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetConfigurationRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetConfigurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetConfigurationRequest) */ {
 public:
  inline GetConfigurationRequest() : GetConfigurationRequest(nullptr) {}
  ~GetConfigurationRequest() override;
  explicit constexpr GetConfigurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConfigurationRequest(const GetConfigurationRequest& from);
  GetConfigurationRequest(GetConfigurationRequest&& from) noexcept
    : GetConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline GetConfigurationRequest& operator=(const GetConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConfigurationRequest& operator=(GetConfigurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConfigurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const GetConfigurationRequest*>(
               &_GetConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetConfigurationRequest& a, GetConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConfigurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConfigurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConfigurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetConfigurationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConfigurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetConfigurationRequest";
  }
  protected:
  explicit GetConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kStoreNameFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kGroupFieldNumber = 3,
    kLabelFieldNumber = 4,
    kSubscribeUpdateFieldNumber = 7,
  };
  // repeated string keys = 5;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string group = 3;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string label = 4;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // bool subscribe_update = 7;
  void clear_subscribe_update();
  bool subscribe_update() const;
  void set_subscribe_update(bool value);
  private:
  bool _internal_subscribe_update() const;
  void _internal_set_subscribe_update(bool value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetConfigurationRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  bool subscribe_update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetConfigurationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetConfigurationResponse) */ {
 public:
  inline GetConfigurationResponse() : GetConfigurationResponse(nullptr) {}
  ~GetConfigurationResponse() override;
  explicit constexpr GetConfigurationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConfigurationResponse(const GetConfigurationResponse& from);
  GetConfigurationResponse(GetConfigurationResponse&& from) noexcept
    : GetConfigurationResponse() {
    *this = ::std::move(from);
  }

  inline GetConfigurationResponse& operator=(const GetConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConfigurationResponse& operator=(GetConfigurationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConfigurationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConfigurationResponse* internal_default_instance() {
    return reinterpret_cast<const GetConfigurationResponse*>(
               &_GetConfigurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetConfigurationResponse& a, GetConfigurationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConfigurationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConfigurationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConfigurationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConfigurationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConfigurationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetConfigurationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConfigurationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetConfigurationResponse";
  }
  protected:
  explicit GetConfigurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .spec.proto.runtime.v1.ConfigurationItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::spec::proto::runtime::v1::ConfigurationItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >*
      mutable_items();
  private:
  const ::spec::proto::runtime::v1::ConfigurationItem& _internal_items(int index) const;
  ::spec::proto::runtime::v1::ConfigurationItem* _internal_add_items();
  public:
  const ::spec::proto::runtime::v1::ConfigurationItem& items(int index) const;
  ::spec::proto::runtime::v1::ConfigurationItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetConfigurationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SubscribeConfigurationRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubscribeConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubscribeConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SubscribeConfigurationRequest_MetadataEntry_DoNotUse();
  explicit constexpr SubscribeConfigurationRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SubscribeConfigurationRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SubscribeConfigurationRequest_MetadataEntry_DoNotUse& other);
  static const SubscribeConfigurationRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SubscribeConfigurationRequest_MetadataEntry_DoNotUse*>(&_SubscribeConfigurationRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.SubscribeConfigurationRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.SubscribeConfigurationRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SubscribeConfigurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SubscribeConfigurationRequest) */ {
 public:
  inline SubscribeConfigurationRequest() : SubscribeConfigurationRequest(nullptr) {}
  ~SubscribeConfigurationRequest() override;
  explicit constexpr SubscribeConfigurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeConfigurationRequest(const SubscribeConfigurationRequest& from);
  SubscribeConfigurationRequest(SubscribeConfigurationRequest&& from) noexcept
    : SubscribeConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeConfigurationRequest& operator=(const SubscribeConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeConfigurationRequest& operator=(SubscribeConfigurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeConfigurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeConfigurationRequest*>(
               &_SubscribeConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SubscribeConfigurationRequest& a, SubscribeConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeConfigurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeConfigurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeConfigurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeConfigurationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeConfigurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SubscribeConfigurationRequest";
  }
  protected:
  explicit SubscribeConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kStoreNameFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kGroupFieldNumber = 3,
    kLabelFieldNumber = 4,
  };
  // repeated string keys = 5;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string group = 3;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string label = 4;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SubscribeConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SubscribeConfigurationRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SubscribeConfigurationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SubscribeConfigurationResponse) */ {
 public:
  inline SubscribeConfigurationResponse() : SubscribeConfigurationResponse(nullptr) {}
  ~SubscribeConfigurationResponse() override;
  explicit constexpr SubscribeConfigurationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeConfigurationResponse(const SubscribeConfigurationResponse& from);
  SubscribeConfigurationResponse(SubscribeConfigurationResponse&& from) noexcept
    : SubscribeConfigurationResponse() {
    *this = ::std::move(from);
  }

  inline SubscribeConfigurationResponse& operator=(const SubscribeConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeConfigurationResponse& operator=(SubscribeConfigurationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeConfigurationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeConfigurationResponse* internal_default_instance() {
    return reinterpret_cast<const SubscribeConfigurationResponse*>(
               &_SubscribeConfigurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SubscribeConfigurationResponse& a, SubscribeConfigurationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeConfigurationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeConfigurationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeConfigurationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeConfigurationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeConfigurationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeConfigurationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeConfigurationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SubscribeConfigurationResponse";
  }
  protected:
  explicit SubscribeConfigurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kStoreNameFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // repeated .spec.proto.runtime.v1.ConfigurationItem items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::spec::proto::runtime::v1::ConfigurationItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >*
      mutable_items();
  private:
  const ::spec::proto::runtime::v1::ConfigurationItem& _internal_items(int index) const;
  ::spec::proto::runtime::v1::ConfigurationItem* _internal_add_items();
  public:
  const ::spec::proto::runtime::v1::ConfigurationItem& items(int index) const;
  ::spec::proto::runtime::v1::ConfigurationItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >&
      items() const;

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SubscribeConfigurationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem > items_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SaveConfigurationRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SaveConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SaveConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SaveConfigurationRequest_MetadataEntry_DoNotUse();
  explicit constexpr SaveConfigurationRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SaveConfigurationRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SaveConfigurationRequest_MetadataEntry_DoNotUse& other);
  static const SaveConfigurationRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SaveConfigurationRequest_MetadataEntry_DoNotUse*>(&_SaveConfigurationRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.SaveConfigurationRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.SaveConfigurationRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SaveConfigurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SaveConfigurationRequest) */ {
 public:
  inline SaveConfigurationRequest() : SaveConfigurationRequest(nullptr) {}
  ~SaveConfigurationRequest() override;
  explicit constexpr SaveConfigurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveConfigurationRequest(const SaveConfigurationRequest& from);
  SaveConfigurationRequest(SaveConfigurationRequest&& from) noexcept
    : SaveConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline SaveConfigurationRequest& operator=(const SaveConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveConfigurationRequest& operator=(SaveConfigurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveConfigurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const SaveConfigurationRequest*>(
               &_SaveConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SaveConfigurationRequest& a, SaveConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveConfigurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveConfigurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveConfigurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveConfigurationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveConfigurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SaveConfigurationRequest";
  }
  protected:
  explicit SaveConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kMetadataFieldNumber = 4,
    kStoreNameFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // repeated .spec.proto.runtime.v1.ConfigurationItem items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::spec::proto::runtime::v1::ConfigurationItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >*
      mutable_items();
  private:
  const ::spec::proto::runtime::v1::ConfigurationItem& _internal_items(int index) const;
  ::spec::proto::runtime::v1::ConfigurationItem* _internal_add_items();
  public:
  const ::spec::proto::runtime::v1::ConfigurationItem& items(int index) const;
  ::spec::proto::runtime::v1::ConfigurationItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >&
      items() const;

  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SaveConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem > items_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SaveConfigurationRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteConfigurationRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteConfigurationRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DeleteConfigurationRequest_MetadataEntry_DoNotUse();
  explicit constexpr DeleteConfigurationRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DeleteConfigurationRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DeleteConfigurationRequest_MetadataEntry_DoNotUse& other);
  static const DeleteConfigurationRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DeleteConfigurationRequest_MetadataEntry_DoNotUse*>(&_DeleteConfigurationRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.DeleteConfigurationRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.DeleteConfigurationRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class DeleteConfigurationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.DeleteConfigurationRequest) */ {
 public:
  inline DeleteConfigurationRequest() : DeleteConfigurationRequest(nullptr) {}
  ~DeleteConfigurationRequest() override;
  explicit constexpr DeleteConfigurationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteConfigurationRequest(const DeleteConfigurationRequest& from);
  DeleteConfigurationRequest(DeleteConfigurationRequest&& from) noexcept
    : DeleteConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteConfigurationRequest& operator=(const DeleteConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteConfigurationRequest& operator=(DeleteConfigurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteConfigurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteConfigurationRequest*>(
               &_DeleteConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DeleteConfigurationRequest& a, DeleteConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteConfigurationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteConfigurationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteConfigurationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteConfigurationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteConfigurationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.DeleteConfigurationRequest";
  }
  protected:
  explicit DeleteConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kStoreNameFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kGroupFieldNumber = 3,
    kLabelFieldNumber = 4,
  };
  // repeated string keys = 5;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string app_id = 2;
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string group = 3;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string label = 4;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.DeleteConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DeleteConfigurationRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetStateRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetStateRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetStateRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetStateRequest_MetadataEntry_DoNotUse();
  explicit constexpr GetStateRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetStateRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetStateRequest_MetadataEntry_DoNotUse& other);
  static const GetStateRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetStateRequest_MetadataEntry_DoNotUse*>(&_GetStateRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetStateRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetStateRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetStateRequest) */ {
 public:
  inline GetStateRequest() : GetStateRequest(nullptr) {}
  ~GetStateRequest() override;
  explicit constexpr GetStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStateRequest(const GetStateRequest& from);
  GetStateRequest(GetStateRequest&& from) noexcept
    : GetStateRequest() {
    *this = ::std::move(from);
  }

  inline GetStateRequest& operator=(const GetStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStateRequest& operator=(GetStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetStateRequest*>(
               &_GetStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(GetStateRequest& a, GetStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetStateRequest";
  }
  protected:
  explicit GetStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 4,
    kStoreNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kConsistencyFieldNumber = 3,
  };
  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .spec.proto.runtime.v1.StateOptions.StateConsistency consistency = 3;
  void clear_consistency();
  ::spec::proto::runtime::v1::StateOptions_StateConsistency consistency() const;
  void set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value);
  private:
  ::spec::proto::runtime::v1::StateOptions_StateConsistency _internal_consistency() const;
  void _internal_set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetStateRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int consistency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetBulkStateRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetBulkStateRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetBulkStateRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetBulkStateRequest_MetadataEntry_DoNotUse();
  explicit constexpr GetBulkStateRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetBulkStateRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetBulkStateRequest_MetadataEntry_DoNotUse& other);
  static const GetBulkStateRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetBulkStateRequest_MetadataEntry_DoNotUse*>(&_GetBulkStateRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetBulkStateRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetBulkStateRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetBulkStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetBulkStateRequest) */ {
 public:
  inline GetBulkStateRequest() : GetBulkStateRequest(nullptr) {}
  ~GetBulkStateRequest() override;
  explicit constexpr GetBulkStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBulkStateRequest(const GetBulkStateRequest& from);
  GetBulkStateRequest(GetBulkStateRequest&& from) noexcept
    : GetBulkStateRequest() {
    *this = ::std::move(from);
  }

  inline GetBulkStateRequest& operator=(const GetBulkStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBulkStateRequest& operator=(GetBulkStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBulkStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBulkStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetBulkStateRequest*>(
               &_GetBulkStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(GetBulkStateRequest& a, GetBulkStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBulkStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBulkStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBulkStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBulkStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBulkStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBulkStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBulkStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetBulkStateRequest";
  }
  protected:
  explicit GetBulkStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kMetadataFieldNumber = 4,
    kStoreNameFieldNumber = 1,
    kParallelismFieldNumber = 3,
  };
  // repeated string keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // int32 parallelism = 3;
  void clear_parallelism();
  int32_t parallelism() const;
  void set_parallelism(int32_t value);
  private:
  int32_t _internal_parallelism() const;
  void _internal_set_parallelism(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetBulkStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetBulkStateRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  int32_t parallelism_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetBulkStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetBulkStateResponse) */ {
 public:
  inline GetBulkStateResponse() : GetBulkStateResponse(nullptr) {}
  ~GetBulkStateResponse() override;
  explicit constexpr GetBulkStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBulkStateResponse(const GetBulkStateResponse& from);
  GetBulkStateResponse(GetBulkStateResponse&& from) noexcept
    : GetBulkStateResponse() {
    *this = ::std::move(from);
  }

  inline GetBulkStateResponse& operator=(const GetBulkStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBulkStateResponse& operator=(GetBulkStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBulkStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBulkStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetBulkStateResponse*>(
               &_GetBulkStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GetBulkStateResponse& a, GetBulkStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBulkStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBulkStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBulkStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBulkStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBulkStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBulkStateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBulkStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetBulkStateResponse";
  }
  protected:
  explicit GetBulkStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .spec.proto.runtime.v1.BulkStateItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::spec::proto::runtime::v1::BulkStateItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::BulkStateItem >*
      mutable_items();
  private:
  const ::spec::proto::runtime::v1::BulkStateItem& _internal_items(int index) const;
  ::spec::proto::runtime::v1::BulkStateItem* _internal_add_items();
  public:
  const ::spec::proto::runtime::v1::BulkStateItem& items(int index) const;
  ::spec::proto::runtime::v1::BulkStateItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::BulkStateItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetBulkStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::BulkStateItem > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class BulkStateItem_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BulkStateItem_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BulkStateItem_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  BulkStateItem_MetadataEntry_DoNotUse();
  explicit constexpr BulkStateItem_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BulkStateItem_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BulkStateItem_MetadataEntry_DoNotUse& other);
  static const BulkStateItem_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BulkStateItem_MetadataEntry_DoNotUse*>(&_BulkStateItem_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.BulkStateItem.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.BulkStateItem.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class BulkStateItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.BulkStateItem) */ {
 public:
  inline BulkStateItem() : BulkStateItem(nullptr) {}
  ~BulkStateItem() override;
  explicit constexpr BulkStateItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulkStateItem(const BulkStateItem& from);
  BulkStateItem(BulkStateItem&& from) noexcept
    : BulkStateItem() {
    *this = ::std::move(from);
  }

  inline BulkStateItem& operator=(const BulkStateItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkStateItem& operator=(BulkStateItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkStateItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkStateItem* internal_default_instance() {
    return reinterpret_cast<const BulkStateItem*>(
               &_BulkStateItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(BulkStateItem& a, BulkStateItem& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkStateItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkStateItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkStateItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulkStateItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulkStateItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BulkStateItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkStateItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.BulkStateItem";
  }
  protected:
  explicit BulkStateItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 5,
    kKeyFieldNumber = 1,
    kDataFieldNumber = 2,
    kEtagFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string etag = 3;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // string error = 4;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.BulkStateItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      BulkStateItem_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class GetStateResponse_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetStateResponse_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetStateResponse_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetStateResponse_MetadataEntry_DoNotUse();
  explicit constexpr GetStateResponse_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetStateResponse_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetStateResponse_MetadataEntry_DoNotUse& other);
  static const GetStateResponse_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetStateResponse_MetadataEntry_DoNotUse*>(&_GetStateResponse_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetStateResponse.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.GetStateResponse.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.GetStateResponse) */ {
 public:
  inline GetStateResponse() : GetStateResponse(nullptr) {}
  ~GetStateResponse() override;
  explicit constexpr GetStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStateResponse(const GetStateResponse& from);
  GetStateResponse(GetStateResponse&& from) noexcept
    : GetStateResponse() {
    *this = ::std::move(from);
  }

  inline GetStateResponse& operator=(const GetStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStateResponse& operator=(GetStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetStateResponse*>(
               &_GetStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(GetStateResponse& a, GetStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetStateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.GetStateResponse";
  }
  protected:
  explicit GetStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kDataFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string etag = 2;
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.GetStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetStateResponse_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteStateRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteStateRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteStateRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DeleteStateRequest_MetadataEntry_DoNotUse();
  explicit constexpr DeleteStateRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DeleteStateRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DeleteStateRequest_MetadataEntry_DoNotUse& other);
  static const DeleteStateRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DeleteStateRequest_MetadataEntry_DoNotUse*>(&_DeleteStateRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.DeleteStateRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.DeleteStateRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class DeleteStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.DeleteStateRequest) */ {
 public:
  inline DeleteStateRequest() : DeleteStateRequest(nullptr) {}
  ~DeleteStateRequest() override;
  explicit constexpr DeleteStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteStateRequest(const DeleteStateRequest& from);
  DeleteStateRequest(DeleteStateRequest&& from) noexcept
    : DeleteStateRequest() {
    *this = ::std::move(from);
  }

  inline DeleteStateRequest& operator=(const DeleteStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteStateRequest& operator=(DeleteStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteStateRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteStateRequest*>(
               &_DeleteStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(DeleteStateRequest& a, DeleteStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.DeleteStateRequest";
  }
  protected:
  explicit DeleteStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 5,
    kStoreNameFieldNumber = 1,
    kKeyFieldNumber = 2,
    kEtagFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .spec.proto.runtime.v1.Etag etag = 3;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const ::spec::proto::runtime::v1::Etag& etag() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::Etag* release_etag();
  ::spec::proto::runtime::v1::Etag* mutable_etag();
  void set_allocated_etag(::spec::proto::runtime::v1::Etag* etag);
  private:
  const ::spec::proto::runtime::v1::Etag& _internal_etag() const;
  ::spec::proto::runtime::v1::Etag* _internal_mutable_etag();
  public:
  void unsafe_arena_set_allocated_etag(
      ::spec::proto::runtime::v1::Etag* etag);
  ::spec::proto::runtime::v1::Etag* unsafe_arena_release_etag();

  // .spec.proto.runtime.v1.StateOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::spec::proto::runtime::v1::StateOptions& options() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::StateOptions* release_options();
  ::spec::proto::runtime::v1::StateOptions* mutable_options();
  void set_allocated_options(::spec::proto::runtime::v1::StateOptions* options);
  private:
  const ::spec::proto::runtime::v1::StateOptions& _internal_options() const;
  ::spec::proto::runtime::v1::StateOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::spec::proto::runtime::v1::StateOptions* options);
  ::spec::proto::runtime::v1::StateOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.DeleteStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DeleteStateRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::spec::proto::runtime::v1::Etag* etag_;
  ::spec::proto::runtime::v1::StateOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class DeleteBulkStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.DeleteBulkStateRequest) */ {
 public:
  inline DeleteBulkStateRequest() : DeleteBulkStateRequest(nullptr) {}
  ~DeleteBulkStateRequest() override;
  explicit constexpr DeleteBulkStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteBulkStateRequest(const DeleteBulkStateRequest& from);
  DeleteBulkStateRequest(DeleteBulkStateRequest&& from) noexcept
    : DeleteBulkStateRequest() {
    *this = ::std::move(from);
  }

  inline DeleteBulkStateRequest& operator=(const DeleteBulkStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteBulkStateRequest& operator=(DeleteBulkStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteBulkStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteBulkStateRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteBulkStateRequest*>(
               &_DeleteBulkStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(DeleteBulkStateRequest& a, DeleteBulkStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteBulkStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteBulkStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteBulkStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteBulkStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteBulkStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteBulkStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteBulkStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.DeleteBulkStateRequest";
  }
  protected:
  explicit DeleteBulkStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 2,
    kStoreNameFieldNumber = 1,
  };
  // repeated .spec.proto.runtime.v1.StateItem states = 2;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::spec::proto::runtime::v1::StateItem* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >*
      mutable_states();
  private:
  const ::spec::proto::runtime::v1::StateItem& _internal_states(int index) const;
  ::spec::proto::runtime::v1::StateItem* _internal_add_states();
  public:
  const ::spec::proto::runtime::v1::StateItem& states(int index) const;
  ::spec::proto::runtime::v1::StateItem* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >&
      states() const;

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.DeleteBulkStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem > states_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class SaveStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.SaveStateRequest) */ {
 public:
  inline SaveStateRequest() : SaveStateRequest(nullptr) {}
  ~SaveStateRequest() override;
  explicit constexpr SaveStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveStateRequest(const SaveStateRequest& from);
  SaveStateRequest(SaveStateRequest&& from) noexcept
    : SaveStateRequest() {
    *this = ::std::move(from);
  }

  inline SaveStateRequest& operator=(const SaveStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveStateRequest& operator=(SaveStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveStateRequest* internal_default_instance() {
    return reinterpret_cast<const SaveStateRequest*>(
               &_SaveStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(SaveStateRequest& a, SaveStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.SaveStateRequest";
  }
  protected:
  explicit SaveStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 2,
    kStoreNameFieldNumber = 1,
  };
  // repeated .spec.proto.runtime.v1.StateItem states = 2;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::spec::proto::runtime::v1::StateItem* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >*
      mutable_states();
  private:
  const ::spec::proto::runtime::v1::StateItem& _internal_states(int index) const;
  ::spec::proto::runtime::v1::StateItem* _internal_add_states();
  public:
  const ::spec::proto::runtime::v1::StateItem& states(int index) const;
  ::spec::proto::runtime::v1::StateItem* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >&
      states() const;

  // string store_name = 1;
  void clear_store_name();
  const std::string& store_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_name();
  PROTOBUF_NODISCARD std::string* release_store_name();
  void set_allocated_store_name(std::string* store_name);
  private:
  const std::string& _internal_store_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_name(const std::string& value);
  std::string* _internal_mutable_store_name();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.SaveStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem > states_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class StateItem_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateItem_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StateItem_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StateItem_MetadataEntry_DoNotUse();
  explicit constexpr StateItem_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StateItem_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StateItem_MetadataEntry_DoNotUse& other);
  static const StateItem_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StateItem_MetadataEntry_DoNotUse*>(&_StateItem_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.StateItem.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.StateItem.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class StateItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.StateItem) */ {
 public:
  inline StateItem() : StateItem(nullptr) {}
  ~StateItem() override;
  explicit constexpr StateItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateItem(const StateItem& from);
  StateItem(StateItem&& from) noexcept
    : StateItem() {
    *this = ::std::move(from);
  }

  inline StateItem& operator=(const StateItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateItem& operator=(StateItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateItem* internal_default_instance() {
    return reinterpret_cast<const StateItem*>(
               &_StateItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(StateItem& a, StateItem& b) {
    a.Swap(&b);
  }
  inline void Swap(StateItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StateItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.StateItem";
  }
  protected:
  explicit StateItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kEtagFieldNumber = 3,
    kOptionsFieldNumber = 5,
  };
  // map<string, string> metadata = 4;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .spec.proto.runtime.v1.Etag etag = 3;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const ::spec::proto::runtime::v1::Etag& etag() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::Etag* release_etag();
  ::spec::proto::runtime::v1::Etag* mutable_etag();
  void set_allocated_etag(::spec::proto::runtime::v1::Etag* etag);
  private:
  const ::spec::proto::runtime::v1::Etag& _internal_etag() const;
  ::spec::proto::runtime::v1::Etag* _internal_mutable_etag();
  public:
  void unsafe_arena_set_allocated_etag(
      ::spec::proto::runtime::v1::Etag* etag);
  ::spec::proto::runtime::v1::Etag* unsafe_arena_release_etag();

  // .spec.proto.runtime.v1.StateOptions options = 5;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::spec::proto::runtime::v1::StateOptions& options() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::StateOptions* release_options();
  ::spec::proto::runtime::v1::StateOptions* mutable_options();
  void set_allocated_options(::spec::proto::runtime::v1::StateOptions* options);
  private:
  const ::spec::proto::runtime::v1::StateOptions& _internal_options() const;
  ::spec::proto::runtime::v1::StateOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::spec::proto::runtime::v1::StateOptions* options);
  ::spec::proto::runtime::v1::StateOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.StateItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StateItem_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::spec::proto::runtime::v1::Etag* etag_;
  ::spec::proto::runtime::v1::StateOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class Etag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.Etag) */ {
 public:
  inline Etag() : Etag(nullptr) {}
  ~Etag() override;
  explicit constexpr Etag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Etag(const Etag& from);
  Etag(Etag&& from) noexcept
    : Etag() {
    *this = ::std::move(from);
  }

  inline Etag& operator=(const Etag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Etag& operator=(Etag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Etag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Etag* internal_default_instance() {
    return reinterpret_cast<const Etag*>(
               &_Etag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Etag& a, Etag& b) {
    a.Swap(&b);
  }
  inline void Swap(Etag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Etag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Etag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Etag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Etag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Etag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Etag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.Etag";
  }
  protected:
  explicit Etag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.Etag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class StateOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.StateOptions) */ {
 public:
  inline StateOptions() : StateOptions(nullptr) {}
  ~StateOptions() override;
  explicit constexpr StateOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateOptions(const StateOptions& from);
  StateOptions(StateOptions&& from) noexcept
    : StateOptions() {
    *this = ::std::move(from);
  }

  inline StateOptions& operator=(const StateOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateOptions& operator=(StateOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateOptions* internal_default_instance() {
    return reinterpret_cast<const StateOptions*>(
               &_StateOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(StateOptions& a, StateOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(StateOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StateOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.StateOptions";
  }
  protected:
  explicit StateOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StateOptions_StateConcurrency StateConcurrency;
  static constexpr StateConcurrency CONCURRENCY_UNSPECIFIED =
    StateOptions_StateConcurrency_CONCURRENCY_UNSPECIFIED;
  static constexpr StateConcurrency CONCURRENCY_FIRST_WRITE =
    StateOptions_StateConcurrency_CONCURRENCY_FIRST_WRITE;
  static constexpr StateConcurrency CONCURRENCY_LAST_WRITE =
    StateOptions_StateConcurrency_CONCURRENCY_LAST_WRITE;
  static inline bool StateConcurrency_IsValid(int value) {
    return StateOptions_StateConcurrency_IsValid(value);
  }
  static constexpr StateConcurrency StateConcurrency_MIN =
    StateOptions_StateConcurrency_StateConcurrency_MIN;
  static constexpr StateConcurrency StateConcurrency_MAX =
    StateOptions_StateConcurrency_StateConcurrency_MAX;
  static constexpr int StateConcurrency_ARRAYSIZE =
    StateOptions_StateConcurrency_StateConcurrency_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StateConcurrency_descriptor() {
    return StateOptions_StateConcurrency_descriptor();
  }
  template<typename T>
  static inline const std::string& StateConcurrency_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StateConcurrency>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StateConcurrency_Name.");
    return StateOptions_StateConcurrency_Name(enum_t_value);
  }
  static inline bool StateConcurrency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StateConcurrency* value) {
    return StateOptions_StateConcurrency_Parse(name, value);
  }

  typedef StateOptions_StateConsistency StateConsistency;
  static constexpr StateConsistency CONSISTENCY_UNSPECIFIED =
    StateOptions_StateConsistency_CONSISTENCY_UNSPECIFIED;
  static constexpr StateConsistency CONSISTENCY_EVENTUAL =
    StateOptions_StateConsistency_CONSISTENCY_EVENTUAL;
  static constexpr StateConsistency CONSISTENCY_STRONG =
    StateOptions_StateConsistency_CONSISTENCY_STRONG;
  static inline bool StateConsistency_IsValid(int value) {
    return StateOptions_StateConsistency_IsValid(value);
  }
  static constexpr StateConsistency StateConsistency_MIN =
    StateOptions_StateConsistency_StateConsistency_MIN;
  static constexpr StateConsistency StateConsistency_MAX =
    StateOptions_StateConsistency_StateConsistency_MAX;
  static constexpr int StateConsistency_ARRAYSIZE =
    StateOptions_StateConsistency_StateConsistency_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StateConsistency_descriptor() {
    return StateOptions_StateConsistency_descriptor();
  }
  template<typename T>
  static inline const std::string& StateConsistency_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StateConsistency>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StateConsistency_Name.");
    return StateOptions_StateConsistency_Name(enum_t_value);
  }
  static inline bool StateConsistency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StateConsistency* value) {
    return StateOptions_StateConsistency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConcurrencyFieldNumber = 1,
    kConsistencyFieldNumber = 2,
  };
  // .spec.proto.runtime.v1.StateOptions.StateConcurrency concurrency = 1;
  void clear_concurrency();
  ::spec::proto::runtime::v1::StateOptions_StateConcurrency concurrency() const;
  void set_concurrency(::spec::proto::runtime::v1::StateOptions_StateConcurrency value);
  private:
  ::spec::proto::runtime::v1::StateOptions_StateConcurrency _internal_concurrency() const;
  void _internal_set_concurrency(::spec::proto::runtime::v1::StateOptions_StateConcurrency value);
  public:

  // .spec.proto.runtime.v1.StateOptions.StateConsistency consistency = 2;
  void clear_consistency();
  ::spec::proto::runtime::v1::StateOptions_StateConsistency consistency() const;
  void set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value);
  private:
  ::spec::proto::runtime::v1::StateOptions_StateConsistency _internal_consistency() const;
  void _internal_set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value);
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.StateOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int concurrency_;
  int consistency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class TransactionalStateOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.TransactionalStateOperation) */ {
 public:
  inline TransactionalStateOperation() : TransactionalStateOperation(nullptr) {}
  ~TransactionalStateOperation() override;
  explicit constexpr TransactionalStateOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionalStateOperation(const TransactionalStateOperation& from);
  TransactionalStateOperation(TransactionalStateOperation&& from) noexcept
    : TransactionalStateOperation() {
    *this = ::std::move(from);
  }

  inline TransactionalStateOperation& operator=(const TransactionalStateOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionalStateOperation& operator=(TransactionalStateOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionalStateOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionalStateOperation* internal_default_instance() {
    return reinterpret_cast<const TransactionalStateOperation*>(
               &_TransactionalStateOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(TransactionalStateOperation& a, TransactionalStateOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionalStateOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionalStateOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionalStateOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionalStateOperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionalStateOperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionalStateOperation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionalStateOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.TransactionalStateOperation";
  }
  protected:
  explicit TransactionalStateOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 1,
    kRequestFieldNumber = 2,
  };
  // string operationType = 1;
  void clear_operationtype();
  const std::string& operationtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operationtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operationtype();
  PROTOBUF_NODISCARD std::string* release_operationtype();
  void set_allocated_operationtype(std::string* operationtype);
  private:
  const std::string& _internal_operationtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operationtype(const std::string& value);
  std::string* _internal_mutable_operationtype();
  public:

  // .spec.proto.runtime.v1.StateItem request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::spec::proto::runtime::v1::StateItem& request() const;
  PROTOBUF_NODISCARD ::spec::proto::runtime::v1::StateItem* release_request();
  ::spec::proto::runtime::v1::StateItem* mutable_request();
  void set_allocated_request(::spec::proto::runtime::v1::StateItem* request);
  private:
  const ::spec::proto::runtime::v1::StateItem& _internal_request() const;
  ::spec::proto::runtime::v1::StateItem* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::spec::proto::runtime::v1::StateItem* request);
  ::spec::proto::runtime::v1::StateItem* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.TransactionalStateOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operationtype_;
  ::spec::proto::runtime::v1::StateItem* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class ExecuteStateTransactionRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteStateTransactionRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ExecuteStateTransactionRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ExecuteStateTransactionRequest_MetadataEntry_DoNotUse();
  explicit constexpr ExecuteStateTransactionRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExecuteStateTransactionRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExecuteStateTransactionRequest_MetadataEntry_DoNotUse& other);
  static const ExecuteStateTransactionRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecuteStateTransactionRequest_MetadataEntry_DoNotUse*>(&_ExecuteStateTransactionRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.ExecuteStateTransactionRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.ExecuteStateTransactionRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ExecuteStateTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.ExecuteStateTransactionRequest) */ {
 public:
  inline ExecuteStateTransactionRequest() : ExecuteStateTransactionRequest(nullptr) {}
  ~ExecuteStateTransactionRequest() override;
  explicit constexpr ExecuteStateTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteStateTransactionRequest(const ExecuteStateTransactionRequest& from);
  ExecuteStateTransactionRequest(ExecuteStateTransactionRequest&& from) noexcept
    : ExecuteStateTransactionRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteStateTransactionRequest& operator=(const ExecuteStateTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteStateTransactionRequest& operator=(ExecuteStateTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteStateTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteStateTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteStateTransactionRequest*>(
               &_ExecuteStateTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ExecuteStateTransactionRequest& a, ExecuteStateTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteStateTransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteStateTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteStateTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteStateTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteStateTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteStateTransactionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteStateTransactionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.ExecuteStateTransactionRequest";
  }
  protected:
  explicit ExecuteStateTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kStoreNameFieldNumber = 1,
  };
  // repeated .spec.proto.runtime.v1.TransactionalStateOperation operations = 2;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::spec::proto::runtime::v1::TransactionalStateOperation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::TransactionalStateOperation >*
      mutable_operations();
  private:
  const ::spec::proto::runtime::v1::TransactionalStateOperation& _internal_operations(int index) const;
  ::spec::proto::runtime::v1::TransactionalStateOperation* _internal_add_operations();
  public:
  const ::spec::proto::runtime::v1::TransactionalStateOperation& operations(int index) const;
  ::spec::proto::runtime::v1::TransactionalStateOperation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::TransactionalStateOperation >&
      operations() const;

  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string storeName = 1;
  void clear_storename();
  const std::string& storename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storename();
  PROTOBUF_NODISCARD std::string* release_storename();
  void set_allocated_storename(std::string* storename);
  private:
  const std::string& _internal_storename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storename(const std::string& value);
  std::string* _internal_mutable_storename();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.ExecuteStateTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::TransactionalStateOperation > operations_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ExecuteStateTransactionRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class PublishEventRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PublishEventRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PublishEventRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PublishEventRequest_MetadataEntry_DoNotUse();
  explicit constexpr PublishEventRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PublishEventRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PublishEventRequest_MetadataEntry_DoNotUse& other);
  static const PublishEventRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PublishEventRequest_MetadataEntry_DoNotUse*>(&_PublishEventRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.PublishEventRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.PublishEventRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class PublishEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.PublishEventRequest) */ {
 public:
  inline PublishEventRequest() : PublishEventRequest(nullptr) {}
  ~PublishEventRequest() override;
  explicit constexpr PublishEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishEventRequest(const PublishEventRequest& from);
  PublishEventRequest(PublishEventRequest&& from) noexcept
    : PublishEventRequest() {
    *this = ::std::move(from);
  }

  inline PublishEventRequest& operator=(const PublishEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishEventRequest& operator=(PublishEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishEventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishEventRequest* internal_default_instance() {
    return reinterpret_cast<const PublishEventRequest*>(
               &_PublishEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(PublishEventRequest& a, PublishEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishEventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishEventRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishEventRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PublishEventRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishEventRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.PublishEventRequest";
  }
  protected:
  explicit PublishEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 5,
    kPubsubNameFieldNumber = 1,
    kTopicFieldNumber = 2,
    kDataFieldNumber = 3,
    kDataContentTypeFieldNumber = 4,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string pubsub_name = 1;
  void clear_pubsub_name();
  const std::string& pubsub_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pubsub_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pubsub_name();
  PROTOBUF_NODISCARD std::string* release_pubsub_name();
  void set_allocated_pubsub_name(std::string* pubsub_name);
  private:
  const std::string& _internal_pubsub_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubsub_name(const std::string& value);
  std::string* _internal_mutable_pubsub_name();
  public:

  // string topic = 2;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string data_content_type = 4;
  void clear_data_content_type();
  const std::string& data_content_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_content_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_content_type();
  PROTOBUF_NODISCARD std::string* release_data_content_type();
  void set_allocated_data_content_type(std::string* data_content_type);
  private:
  const std::string& _internal_data_content_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_content_type(const std::string& value);
  std::string* _internal_mutable_data_content_type();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.PublishEventRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PublishEventRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubsub_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_content_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class InvokeBindingRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InvokeBindingRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InvokeBindingRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InvokeBindingRequest_MetadataEntry_DoNotUse();
  explicit constexpr InvokeBindingRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InvokeBindingRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InvokeBindingRequest_MetadataEntry_DoNotUse& other);
  static const InvokeBindingRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InvokeBindingRequest_MetadataEntry_DoNotUse*>(&_InvokeBindingRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.InvokeBindingRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.InvokeBindingRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class InvokeBindingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.InvokeBindingRequest) */ {
 public:
  inline InvokeBindingRequest() : InvokeBindingRequest(nullptr) {}
  ~InvokeBindingRequest() override;
  explicit constexpr InvokeBindingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeBindingRequest(const InvokeBindingRequest& from);
  InvokeBindingRequest(InvokeBindingRequest&& from) noexcept
    : InvokeBindingRequest() {
    *this = ::std::move(from);
  }

  inline InvokeBindingRequest& operator=(const InvokeBindingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeBindingRequest& operator=(InvokeBindingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeBindingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeBindingRequest* internal_default_instance() {
    return reinterpret_cast<const InvokeBindingRequest*>(
               &_InvokeBindingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(InvokeBindingRequest& a, InvokeBindingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeBindingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeBindingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeBindingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeBindingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeBindingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeBindingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeBindingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.InvokeBindingRequest";
  }
  protected:
  explicit InvokeBindingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
    kOperationFieldNumber = 4,
  };
  // map<string, string> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string operation = 4;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.InvokeBindingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InvokeBindingRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// -------------------------------------------------------------------

class InvokeBindingResponse_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InvokeBindingResponse_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InvokeBindingResponse_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InvokeBindingResponse_MetadataEntry_DoNotUse();
  explicit constexpr InvokeBindingResponse_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InvokeBindingResponse_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InvokeBindingResponse_MetadataEntry_DoNotUse& other);
  static const InvokeBindingResponse_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InvokeBindingResponse_MetadataEntry_DoNotUse*>(&_InvokeBindingResponse_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.InvokeBindingResponse.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "spec.proto.runtime.v1.InvokeBindingResponse.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class InvokeBindingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:spec.proto.runtime.v1.InvokeBindingResponse) */ {
 public:
  inline InvokeBindingResponse() : InvokeBindingResponse(nullptr) {}
  ~InvokeBindingResponse() override;
  explicit constexpr InvokeBindingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeBindingResponse(const InvokeBindingResponse& from);
  InvokeBindingResponse(InvokeBindingResponse&& from) noexcept
    : InvokeBindingResponse() {
    *this = ::std::move(from);
  }

  inline InvokeBindingResponse& operator=(const InvokeBindingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeBindingResponse& operator=(InvokeBindingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeBindingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeBindingResponse* internal_default_instance() {
    return reinterpret_cast<const InvokeBindingResponse*>(
               &_InvokeBindingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(InvokeBindingResponse& a, InvokeBindingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeBindingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeBindingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeBindingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeBindingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeBindingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeBindingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeBindingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "spec.proto.runtime.v1.InvokeBindingResponse";
  }
  protected:
  explicit InvokeBindingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 2,
    kDataFieldNumber = 1,
  };
  // map<string, string> metadata = 2;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:spec.proto.runtime.v1.InvokeBindingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InvokeBindingResponse_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_runtime_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetFileMetaRequest

// .spec.proto.runtime.v1.FileRequest request = 1;
inline bool GetFileMetaRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool GetFileMetaRequest::has_request() const {
  return _internal_has_request();
}
inline void GetFileMetaRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::spec::proto::runtime::v1::FileRequest& GetFileMetaRequest::_internal_request() const {
  const ::spec::proto::runtime::v1::FileRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::FileRequest&>(
      ::spec::proto::runtime::v1::_FileRequest_default_instance_);
}
inline const ::spec::proto::runtime::v1::FileRequest& GetFileMetaRequest::request() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileMetaRequest.request)
  return _internal_request();
}
inline void GetFileMetaRequest::unsafe_arena_set_allocated_request(
    ::spec::proto::runtime::v1::FileRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.GetFileMetaRequest.request)
}
inline ::spec::proto::runtime::v1::FileRequest* GetFileMetaRequest::release_request() {
  
  ::spec::proto::runtime::v1::FileRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::FileRequest* GetFileMetaRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetFileMetaRequest.request)
  
  ::spec::proto::runtime::v1::FileRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::FileRequest* GetFileMetaRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::FileRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::spec::proto::runtime::v1::FileRequest* GetFileMetaRequest::mutable_request() {
  ::spec::proto::runtime::v1::FileRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetFileMetaRequest.request)
  return _msg;
}
inline void GetFileMetaRequest::set_allocated_request(::spec::proto::runtime::v1::FileRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::FileRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetFileMetaRequest.request)
}

// -------------------------------------------------------------------

// GetFileMetaResponse

// int64 size = 1;
inline void GetFileMetaResponse::clear_size() {
  size_ = int64_t{0};
}
inline int64_t GetFileMetaResponse::_internal_size() const {
  return size_;
}
inline int64_t GetFileMetaResponse::size() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileMetaResponse.size)
  return _internal_size();
}
inline void GetFileMetaResponse::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void GetFileMetaResponse::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetFileMetaResponse.size)
}

// string last_modified = 2;
inline void GetFileMetaResponse::clear_last_modified() {
  last_modified_.ClearToEmpty();
}
inline const std::string& GetFileMetaResponse::last_modified() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileMetaResponse.last_modified)
  return _internal_last_modified();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaResponse::set_last_modified(ArgT0&& arg0, ArgT... args) {
 
 last_modified_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetFileMetaResponse.last_modified)
}
inline std::string* GetFileMetaResponse::mutable_last_modified() {
  std::string* _s = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetFileMetaResponse.last_modified)
  return _s;
}
inline const std::string& GetFileMetaResponse::_internal_last_modified() const {
  return last_modified_.Get();
}
inline void GetFileMetaResponse::_internal_set_last_modified(const std::string& value) {
  
  last_modified_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaResponse::_internal_mutable_last_modified() {
  
  return last_modified_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaResponse::release_last_modified() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetFileMetaResponse.last_modified)
  return last_modified_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaResponse::set_allocated_last_modified(std::string* last_modified) {
  if (last_modified != nullptr) {
    
  } else {
    
  }
  last_modified_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_modified,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_modified_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_modified_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetFileMetaResponse.last_modified)
}

// .spec.proto.runtime.v1.FileMeta response = 3;
inline bool GetFileMetaResponse::_internal_has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline bool GetFileMetaResponse::has_response() const {
  return _internal_has_response();
}
inline void GetFileMetaResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::spec::proto::runtime::v1::FileMeta& GetFileMetaResponse::_internal_response() const {
  const ::spec::proto::runtime::v1::FileMeta* p = response_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::FileMeta&>(
      ::spec::proto::runtime::v1::_FileMeta_default_instance_);
}
inline const ::spec::proto::runtime::v1::FileMeta& GetFileMetaResponse::response() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileMetaResponse.response)
  return _internal_response();
}
inline void GetFileMetaResponse::unsafe_arena_set_allocated_response(
    ::spec::proto::runtime::v1::FileMeta* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.GetFileMetaResponse.response)
}
inline ::spec::proto::runtime::v1::FileMeta* GetFileMetaResponse::release_response() {
  
  ::spec::proto::runtime::v1::FileMeta* temp = response_;
  response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::FileMeta* GetFileMetaResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetFileMetaResponse.response)
  
  ::spec::proto::runtime::v1::FileMeta* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::FileMeta* GetFileMetaResponse::_internal_mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::FileMeta>(GetArenaForAllocation());
    response_ = p;
  }
  return response_;
}
inline ::spec::proto::runtime::v1::FileMeta* GetFileMetaResponse::mutable_response() {
  ::spec::proto::runtime::v1::FileMeta* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetFileMetaResponse.response)
  return _msg;
}
inline void GetFileMetaResponse::set_allocated_response(::spec::proto::runtime::v1::FileMeta* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::FileMeta>::GetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetFileMetaResponse.response)
}

// -------------------------------------------------------------------

// FileMetaValue

// repeated string value = 1;
inline int FileMetaValue::_internal_value_size() const {
  return value_.size();
}
inline int FileMetaValue::value_size() const {
  return _internal_value_size();
}
inline void FileMetaValue::clear_value() {
  value_.Clear();
}
inline std::string* FileMetaValue::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:spec.proto.runtime.v1.FileMetaValue.value)
  return _s;
}
inline const std::string& FileMetaValue::_internal_value(int index) const {
  return value_.Get(index);
}
inline const std::string& FileMetaValue::value(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.FileMetaValue.value)
  return _internal_value(index);
}
inline std::string* FileMetaValue::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.FileMetaValue.value)
  return value_.Mutable(index);
}
inline void FileMetaValue::set_value(int index, const std::string& value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileMetaValue.value)
}
inline void FileMetaValue::set_value(int index, std::string&& value) {
  value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileMetaValue.value)
}
inline void FileMetaValue::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spec.proto.runtime.v1.FileMetaValue.value)
}
inline void FileMetaValue::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spec.proto.runtime.v1.FileMetaValue.value)
}
inline std::string* FileMetaValue::_internal_add_value() {
  return value_.Add();
}
inline void FileMetaValue::add_value(const std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.FileMetaValue.value)
}
inline void FileMetaValue::add_value(std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.FileMetaValue.value)
}
inline void FileMetaValue::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spec.proto.runtime.v1.FileMetaValue.value)
}
inline void FileMetaValue::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spec.proto.runtime.v1.FileMetaValue.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FileMetaValue::value() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.FileMetaValue.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FileMetaValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.FileMetaValue.value)
  return &value_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FileMeta

// map<string, .spec.proto.runtime.v1.FileMetaValue> metadata = 1;
inline int FileMeta::_internal_metadata_size() const {
  return metadata_.size();
}
inline int FileMeta::metadata_size() const {
  return _internal_metadata_size();
}
inline void FileMeta::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >&
FileMeta::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >&
FileMeta::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.FileMeta.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >*
FileMeta::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::spec::proto::runtime::v1::FileMetaValue >*
FileMeta::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.FileMeta.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetFileRequest

// string store_name = 1;
inline void GetFileRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& GetFileRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetFileRequest.store_name)
}
inline std::string* GetFileRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetFileRequest.store_name)
  return _s;
}
inline const std::string& GetFileRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void GetFileRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetFileRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetFileRequest.store_name)
}

// string name = 2;
inline void GetFileRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetFileRequest::name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetFileRequest.name)
}
inline std::string* GetFileRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetFileRequest.name)
  return _s;
}
inline const std::string& GetFileRequest::_internal_name() const {
  return name_.Get();
}
inline void GetFileRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileRequest::release_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetFileRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetFileRequest.name)
}

// map<string, string> metadata = 3;
inline int GetFileRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int GetFileRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetFileRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFileRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFileRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.GetFileRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFileRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFileRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.GetFileRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// GetFileResponse

// bytes data = 1;
inline void GetFileResponse::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& GetFileResponse::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetFileResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetFileResponse.data)
}
inline std::string* GetFileResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetFileResponse.data)
  return _s;
}
inline const std::string& GetFileResponse::_internal_data() const {
  return data_.Get();
}
inline void GetFileResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileResponse::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileResponse::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetFileResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetFileResponse.data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PutFileRequest

// string store_name = 1;
inline void PutFileRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& PutFileRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PutFileRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PutFileRequest.store_name)
}
inline std::string* PutFileRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PutFileRequest.store_name)
  return _s;
}
inline const std::string& PutFileRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void PutFileRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PutFileRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PutFileRequest.store_name)
}

// string name = 2;
inline void PutFileRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PutFileRequest::name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PutFileRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PutFileRequest.name)
}
inline std::string* PutFileRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PutFileRequest.name)
  return _s;
}
inline const std::string& PutFileRequest::_internal_name() const {
  return name_.Get();
}
inline void PutFileRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileRequest::release_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PutFileRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PutFileRequest.name)
}

// bytes data = 3;
inline void PutFileRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PutFileRequest::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PutFileRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutFileRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PutFileRequest.data)
}
inline std::string* PutFileRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PutFileRequest.data)
  return _s;
}
inline const std::string& PutFileRequest::_internal_data() const {
  return data_.Get();
}
inline void PutFileRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PutFileRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PutFileRequest::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PutFileRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PutFileRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PutFileRequest.data)
}

// map<string, string> metadata = 4;
inline int PutFileRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int PutFileRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void PutFileRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PutFileRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PutFileRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.PutFileRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PutFileRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PutFileRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.PutFileRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FileRequest

// string store_name = 1;
inline void FileRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& FileRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.FileRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileRequest.store_name)
}
inline std::string* FileRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.FileRequest.store_name)
  return _s;
}
inline const std::string& FileRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void FileRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.FileRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.FileRequest.store_name)
}

// string name = 2;
inline void FileRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FileRequest::name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.FileRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileRequest.name)
}
inline std::string* FileRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.FileRequest.name)
  return _s;
}
inline const std::string& FileRequest::_internal_name() const {
  return name_.Get();
}
inline void FileRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileRequest::release_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.FileRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.FileRequest.name)
}

// map<string, string> metadata = 3;
inline int FileRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int FileRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void FileRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FileRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FileRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.FileRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FileRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FileRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.FileRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// ListFileRequest

// .spec.proto.runtime.v1.FileRequest request = 1;
inline bool ListFileRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool ListFileRequest::has_request() const {
  return _internal_has_request();
}
inline void ListFileRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::spec::proto::runtime::v1::FileRequest& ListFileRequest::_internal_request() const {
  const ::spec::proto::runtime::v1::FileRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::FileRequest&>(
      ::spec::proto::runtime::v1::_FileRequest_default_instance_);
}
inline const ::spec::proto::runtime::v1::FileRequest& ListFileRequest::request() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ListFileRequest.request)
  return _internal_request();
}
inline void ListFileRequest::unsafe_arena_set_allocated_request(
    ::spec::proto::runtime::v1::FileRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.ListFileRequest.request)
}
inline ::spec::proto::runtime::v1::FileRequest* ListFileRequest::release_request() {
  
  ::spec::proto::runtime::v1::FileRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::FileRequest* ListFileRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ListFileRequest.request)
  
  ::spec::proto::runtime::v1::FileRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::FileRequest* ListFileRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::FileRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::spec::proto::runtime::v1::FileRequest* ListFileRequest::mutable_request() {
  ::spec::proto::runtime::v1::FileRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ListFileRequest.request)
  return _msg;
}
inline void ListFileRequest::set_allocated_request(::spec::proto::runtime::v1::FileRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::FileRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ListFileRequest.request)
}

// int32 page_size = 2;
inline void ListFileRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListFileRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListFileRequest::page_size() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ListFileRequest.page_size)
  return _internal_page_size();
}
inline void ListFileRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListFileRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ListFileRequest.page_size)
}

// string marker = 3;
inline void ListFileRequest::clear_marker() {
  marker_.ClearToEmpty();
}
inline const std::string& ListFileRequest::marker() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ListFileRequest.marker)
  return _internal_marker();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListFileRequest::set_marker(ArgT0&& arg0, ArgT... args) {
 
 marker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ListFileRequest.marker)
}
inline std::string* ListFileRequest::mutable_marker() {
  std::string* _s = _internal_mutable_marker();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ListFileRequest.marker)
  return _s;
}
inline const std::string& ListFileRequest::_internal_marker() const {
  return marker_.Get();
}
inline void ListFileRequest::_internal_set_marker(const std::string& value) {
  
  marker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListFileRequest::_internal_mutable_marker() {
  
  return marker_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListFileRequest::release_marker() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ListFileRequest.marker)
  return marker_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListFileRequest::set_allocated_marker(std::string* marker) {
  if (marker != nullptr) {
    
  } else {
    
  }
  marker_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), marker,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (marker_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    marker_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ListFileRequest.marker)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FileInfo

// string file_name = 1;
inline void FileInfo::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& FileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.FileInfo.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileInfo.file_name)
}
inline std::string* FileInfo::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.FileInfo.file_name)
  return _s;
}
inline const std::string& FileInfo::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileInfo::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_file_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.FileInfo.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileInfo::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.FileInfo.file_name)
}

// int64 size = 2;
inline void FileInfo::clear_size() {
  size_ = int64_t{0};
}
inline int64_t FileInfo::_internal_size() const {
  return size_;
}
inline int64_t FileInfo::size() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.FileInfo.size)
  return _internal_size();
}
inline void FileInfo::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void FileInfo::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileInfo.size)
}

// string last_modified = 3;
inline void FileInfo::clear_last_modified() {
  last_modified_.ClearToEmpty();
}
inline const std::string& FileInfo::last_modified() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.FileInfo.last_modified)
  return _internal_last_modified();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_last_modified(ArgT0&& arg0, ArgT... args) {
 
 last_modified_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.FileInfo.last_modified)
}
inline std::string* FileInfo::mutable_last_modified() {
  std::string* _s = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.FileInfo.last_modified)
  return _s;
}
inline const std::string& FileInfo::_internal_last_modified() const {
  return last_modified_.Get();
}
inline void FileInfo::_internal_set_last_modified(const std::string& value) {
  
  last_modified_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_last_modified() {
  
  return last_modified_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileInfo::release_last_modified() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.FileInfo.last_modified)
  return last_modified_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileInfo::set_allocated_last_modified(std::string* last_modified) {
  if (last_modified != nullptr) {
    
  } else {
    
  }
  last_modified_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_modified,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_modified_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_modified_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.FileInfo.last_modified)
}

// map<string, string> metadata = 4;
inline int FileInfo::_internal_metadata_size() const {
  return metadata_.size();
}
inline int FileInfo::metadata_size() const {
  return _internal_metadata_size();
}
inline void FileInfo::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FileInfo::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FileInfo::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.FileInfo.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FileInfo::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FileInfo::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.FileInfo.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// ListFileResp

// repeated .spec.proto.runtime.v1.FileInfo files = 1;
inline int ListFileResp::_internal_files_size() const {
  return files_.size();
}
inline int ListFileResp::files_size() const {
  return _internal_files_size();
}
inline void ListFileResp::clear_files() {
  files_.Clear();
}
inline ::spec::proto::runtime::v1::FileInfo* ListFileResp::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ListFileResp.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::FileInfo >*
ListFileResp::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.ListFileResp.files)
  return &files_;
}
inline const ::spec::proto::runtime::v1::FileInfo& ListFileResp::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::spec::proto::runtime::v1::FileInfo& ListFileResp::files(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ListFileResp.files)
  return _internal_files(index);
}
inline ::spec::proto::runtime::v1::FileInfo* ListFileResp::_internal_add_files() {
  return files_.Add();
}
inline ::spec::proto::runtime::v1::FileInfo* ListFileResp::add_files() {
  ::spec::proto::runtime::v1::FileInfo* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.ListFileResp.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::FileInfo >&
ListFileResp::files() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.ListFileResp.files)
  return files_;
}

// string marker = 2;
inline void ListFileResp::clear_marker() {
  marker_.ClearToEmpty();
}
inline const std::string& ListFileResp::marker() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ListFileResp.marker)
  return _internal_marker();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListFileResp::set_marker(ArgT0&& arg0, ArgT... args) {
 
 marker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ListFileResp.marker)
}
inline std::string* ListFileResp::mutable_marker() {
  std::string* _s = _internal_mutable_marker();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ListFileResp.marker)
  return _s;
}
inline const std::string& ListFileResp::_internal_marker() const {
  return marker_.Get();
}
inline void ListFileResp::_internal_set_marker(const std::string& value) {
  
  marker_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListFileResp::_internal_mutable_marker() {
  
  return marker_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListFileResp::release_marker() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ListFileResp.marker)
  return marker_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListFileResp::set_allocated_marker(std::string* marker) {
  if (marker != nullptr) {
    
  } else {
    
  }
  marker_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), marker,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (marker_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    marker_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ListFileResp.marker)
}

// bool is_truncated = 3;
inline void ListFileResp::clear_is_truncated() {
  is_truncated_ = false;
}
inline bool ListFileResp::_internal_is_truncated() const {
  return is_truncated_;
}
inline bool ListFileResp::is_truncated() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ListFileResp.is_truncated)
  return _internal_is_truncated();
}
inline void ListFileResp::_internal_set_is_truncated(bool value) {
  
  is_truncated_ = value;
}
inline void ListFileResp::set_is_truncated(bool value) {
  _internal_set_is_truncated(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ListFileResp.is_truncated)
}

// -------------------------------------------------------------------

// DelFileRequest

// .spec.proto.runtime.v1.FileRequest request = 1;
inline bool DelFileRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool DelFileRequest::has_request() const {
  return _internal_has_request();
}
inline void DelFileRequest::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::spec::proto::runtime::v1::FileRequest& DelFileRequest::_internal_request() const {
  const ::spec::proto::runtime::v1::FileRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::FileRequest&>(
      ::spec::proto::runtime::v1::_FileRequest_default_instance_);
}
inline const ::spec::proto::runtime::v1::FileRequest& DelFileRequest::request() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DelFileRequest.request)
  return _internal_request();
}
inline void DelFileRequest::unsafe_arena_set_allocated_request(
    ::spec::proto::runtime::v1::FileRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.DelFileRequest.request)
}
inline ::spec::proto::runtime::v1::FileRequest* DelFileRequest::release_request() {
  
  ::spec::proto::runtime::v1::FileRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::FileRequest* DelFileRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DelFileRequest.request)
  
  ::spec::proto::runtime::v1::FileRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::FileRequest* DelFileRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::FileRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::spec::proto::runtime::v1::FileRequest* DelFileRequest::mutable_request() {
  ::spec::proto::runtime::v1::FileRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DelFileRequest.request)
  return _msg;
}
inline void DelFileRequest::set_allocated_request(::spec::proto::runtime::v1::FileRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::FileRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DelFileRequest.request)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetNextIdRequest

// string store_name = 1;
inline void GetNextIdRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& GetNextIdRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetNextIdRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNextIdRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetNextIdRequest.store_name)
}
inline std::string* GetNextIdRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetNextIdRequest.store_name)
  return _s;
}
inline const std::string& GetNextIdRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void GetNextIdRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNextIdRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNextIdRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetNextIdRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNextIdRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetNextIdRequest.store_name)
}

// string key = 2;
inline void GetNextIdRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& GetNextIdRequest::key() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetNextIdRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNextIdRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetNextIdRequest.key)
}
inline std::string* GetNextIdRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetNextIdRequest.key)
  return _s;
}
inline const std::string& GetNextIdRequest::_internal_key() const {
  return key_.Get();
}
inline void GetNextIdRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNextIdRequest::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNextIdRequest::release_key() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetNextIdRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNextIdRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetNextIdRequest.key)
}

// .spec.proto.runtime.v1.SequencerOptions options = 3;
inline bool GetNextIdRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool GetNextIdRequest::has_options() const {
  return _internal_has_options();
}
inline void GetNextIdRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::spec::proto::runtime::v1::SequencerOptions& GetNextIdRequest::_internal_options() const {
  const ::spec::proto::runtime::v1::SequencerOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::SequencerOptions&>(
      ::spec::proto::runtime::v1::_SequencerOptions_default_instance_);
}
inline const ::spec::proto::runtime::v1::SequencerOptions& GetNextIdRequest::options() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetNextIdRequest.options)
  return _internal_options();
}
inline void GetNextIdRequest::unsafe_arena_set_allocated_options(
    ::spec::proto::runtime::v1::SequencerOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.GetNextIdRequest.options)
}
inline ::spec::proto::runtime::v1::SequencerOptions* GetNextIdRequest::release_options() {
  
  ::spec::proto::runtime::v1::SequencerOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::SequencerOptions* GetNextIdRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetNextIdRequest.options)
  
  ::spec::proto::runtime::v1::SequencerOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::SequencerOptions* GetNextIdRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::SequencerOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::spec::proto::runtime::v1::SequencerOptions* GetNextIdRequest::mutable_options() {
  ::spec::proto::runtime::v1::SequencerOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetNextIdRequest.options)
  return _msg;
}
inline void GetNextIdRequest::set_allocated_options(::spec::proto::runtime::v1::SequencerOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::SequencerOptions>::GetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetNextIdRequest.options)
}

// map<string, string> metadata = 4;
inline int GetNextIdRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int GetNextIdRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetNextIdRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetNextIdRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetNextIdRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.GetNextIdRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetNextIdRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetNextIdRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.GetNextIdRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// SequencerOptions

// .spec.proto.runtime.v1.SequencerOptions.AutoIncrement increment = 1;
inline void SequencerOptions::clear_increment() {
  increment_ = 0;
}
inline ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement SequencerOptions::_internal_increment() const {
  return static_cast< ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement >(increment_);
}
inline ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement SequencerOptions::increment() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SequencerOptions.increment)
  return _internal_increment();
}
inline void SequencerOptions::_internal_set_increment(::spec::proto::runtime::v1::SequencerOptions_AutoIncrement value) {
  
  increment_ = value;
}
inline void SequencerOptions::set_increment(::spec::proto::runtime::v1::SequencerOptions_AutoIncrement value) {
  _internal_set_increment(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SequencerOptions.increment)
}

// -------------------------------------------------------------------

// GetNextIdResponse

// int64 next_id = 1;
inline void GetNextIdResponse::clear_next_id() {
  next_id_ = int64_t{0};
}
inline int64_t GetNextIdResponse::_internal_next_id() const {
  return next_id_;
}
inline int64_t GetNextIdResponse::next_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetNextIdResponse.next_id)
  return _internal_next_id();
}
inline void GetNextIdResponse::_internal_set_next_id(int64_t value) {
  
  next_id_ = value;
}
inline void GetNextIdResponse::set_next_id(int64_t value) {
  _internal_set_next_id(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetNextIdResponse.next_id)
}

// -------------------------------------------------------------------

// TryLockRequest

// string store_name = 1;
inline void TryLockRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& TryLockRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TryLockRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TryLockRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.TryLockRequest.store_name)
}
inline std::string* TryLockRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.TryLockRequest.store_name)
  return _s;
}
inline const std::string& TryLockRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void TryLockRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TryLockRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TryLockRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.TryLockRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TryLockRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.TryLockRequest.store_name)
}

// string resource_id = 2;
inline void TryLockRequest::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& TryLockRequest::resource_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TryLockRequest.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TryLockRequest::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.TryLockRequest.resource_id)
}
inline std::string* TryLockRequest::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.TryLockRequest.resource_id)
  return _s;
}
inline const std::string& TryLockRequest::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void TryLockRequest::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TryLockRequest::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TryLockRequest::release_resource_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.TryLockRequest.resource_id)
  return resource_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TryLockRequest::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.TryLockRequest.resource_id)
}

// string lock_owner = 3;
inline void TryLockRequest::clear_lock_owner() {
  lock_owner_.ClearToEmpty();
}
inline const std::string& TryLockRequest::lock_owner() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TryLockRequest.lock_owner)
  return _internal_lock_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TryLockRequest::set_lock_owner(ArgT0&& arg0, ArgT... args) {
 
 lock_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.TryLockRequest.lock_owner)
}
inline std::string* TryLockRequest::mutable_lock_owner() {
  std::string* _s = _internal_mutable_lock_owner();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.TryLockRequest.lock_owner)
  return _s;
}
inline const std::string& TryLockRequest::_internal_lock_owner() const {
  return lock_owner_.Get();
}
inline void TryLockRequest::_internal_set_lock_owner(const std::string& value) {
  
  lock_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TryLockRequest::_internal_mutable_lock_owner() {
  
  return lock_owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TryLockRequest::release_lock_owner() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.TryLockRequest.lock_owner)
  return lock_owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TryLockRequest::set_allocated_lock_owner(std::string* lock_owner) {
  if (lock_owner != nullptr) {
    
  } else {
    
  }
  lock_owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lock_owner,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lock_owner_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lock_owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.TryLockRequest.lock_owner)
}

// int32 expire = 4;
inline void TryLockRequest::clear_expire() {
  expire_ = 0;
}
inline int32_t TryLockRequest::_internal_expire() const {
  return expire_;
}
inline int32_t TryLockRequest::expire() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TryLockRequest.expire)
  return _internal_expire();
}
inline void TryLockRequest::_internal_set_expire(int32_t value) {
  
  expire_ = value;
}
inline void TryLockRequest::set_expire(int32_t value) {
  _internal_set_expire(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.TryLockRequest.expire)
}

// -------------------------------------------------------------------

// TryLockResponse

// bool success = 1;
inline void TryLockResponse::clear_success() {
  success_ = false;
}
inline bool TryLockResponse::_internal_success() const {
  return success_;
}
inline bool TryLockResponse::success() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TryLockResponse.success)
  return _internal_success();
}
inline void TryLockResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void TryLockResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.TryLockResponse.success)
}

// -------------------------------------------------------------------

// UnlockRequest

// string store_name = 1;
inline void UnlockRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& UnlockRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.UnlockRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlockRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.UnlockRequest.store_name)
}
inline std::string* UnlockRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.UnlockRequest.store_name)
  return _s;
}
inline const std::string& UnlockRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void UnlockRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnlockRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnlockRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.UnlockRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnlockRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.UnlockRequest.store_name)
}

// string resource_id = 2;
inline void UnlockRequest::clear_resource_id() {
  resource_id_.ClearToEmpty();
}
inline const std::string& UnlockRequest::resource_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.UnlockRequest.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlockRequest::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 resource_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.UnlockRequest.resource_id)
}
inline std::string* UnlockRequest::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.UnlockRequest.resource_id)
  return _s;
}
inline const std::string& UnlockRequest::_internal_resource_id() const {
  return resource_id_.Get();
}
inline void UnlockRequest::_internal_set_resource_id(const std::string& value) {
  
  resource_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnlockRequest::_internal_mutable_resource_id() {
  
  return resource_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnlockRequest::release_resource_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.UnlockRequest.resource_id)
  return resource_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnlockRequest::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  resource_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resource_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    resource_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.UnlockRequest.resource_id)
}

// string lock_owner = 3;
inline void UnlockRequest::clear_lock_owner() {
  lock_owner_.ClearToEmpty();
}
inline const std::string& UnlockRequest::lock_owner() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.UnlockRequest.lock_owner)
  return _internal_lock_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlockRequest::set_lock_owner(ArgT0&& arg0, ArgT... args) {
 
 lock_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.UnlockRequest.lock_owner)
}
inline std::string* UnlockRequest::mutable_lock_owner() {
  std::string* _s = _internal_mutable_lock_owner();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.UnlockRequest.lock_owner)
  return _s;
}
inline const std::string& UnlockRequest::_internal_lock_owner() const {
  return lock_owner_.Get();
}
inline void UnlockRequest::_internal_set_lock_owner(const std::string& value) {
  
  lock_owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnlockRequest::_internal_mutable_lock_owner() {
  
  return lock_owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnlockRequest::release_lock_owner() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.UnlockRequest.lock_owner)
  return lock_owner_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnlockRequest::set_allocated_lock_owner(std::string* lock_owner) {
  if (lock_owner != nullptr) {
    
  } else {
    
  }
  lock_owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lock_owner,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lock_owner_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lock_owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.UnlockRequest.lock_owner)
}

// -------------------------------------------------------------------

// UnlockResponse

// .spec.proto.runtime.v1.UnlockResponse.Status status = 1;
inline void UnlockResponse::clear_status() {
  status_ = 0;
}
inline ::spec::proto::runtime::v1::UnlockResponse_Status UnlockResponse::_internal_status() const {
  return static_cast< ::spec::proto::runtime::v1::UnlockResponse_Status >(status_);
}
inline ::spec::proto::runtime::v1::UnlockResponse_Status UnlockResponse::status() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.UnlockResponse.status)
  return _internal_status();
}
inline void UnlockResponse::_internal_set_status(::spec::proto::runtime::v1::UnlockResponse_Status value) {
  
  status_ = value;
}
inline void UnlockResponse::set_status(::spec::proto::runtime::v1::UnlockResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.UnlockResponse.status)
}

// -------------------------------------------------------------------

// SayHelloRequest

// string service_name = 1;
inline void SayHelloRequest::clear_service_name() {
  service_name_.ClearToEmpty();
}
inline const std::string& SayHelloRequest::service_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SayHelloRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SayHelloRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SayHelloRequest.service_name)
}
inline std::string* SayHelloRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SayHelloRequest.service_name)
  return _s;
}
inline const std::string& SayHelloRequest::_internal_service_name() const {
  return service_name_.Get();
}
inline void SayHelloRequest::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SayHelloRequest::_internal_mutable_service_name() {
  
  return service_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SayHelloRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SayHelloRequest.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SayHelloRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SayHelloRequest.service_name)
}

// string name = 2;
inline void SayHelloRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SayHelloRequest::name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SayHelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SayHelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SayHelloRequest.name)
}
inline std::string* SayHelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SayHelloRequest.name)
  return _s;
}
inline const std::string& SayHelloRequest::_internal_name() const {
  return name_.Get();
}
inline void SayHelloRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SayHelloRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SayHelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SayHelloRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SayHelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SayHelloRequest.name)
}

// .google.protobuf.Any data = 3;
inline bool SayHelloRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool SayHelloRequest::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SayHelloRequest::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SayHelloRequest::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SayHelloRequest.data)
  return _internal_data();
}
inline void SayHelloRequest::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Any* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.SayHelloRequest.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloRequest::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SayHelloRequest.data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloRequest::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SayHelloRequest.data)
  return _msg;
}
inline void SayHelloRequest::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SayHelloRequest.data)
}

// -------------------------------------------------------------------

// SayHelloResponse

// string hello = 1;
inline void SayHelloResponse::clear_hello() {
  hello_.ClearToEmpty();
}
inline const std::string& SayHelloResponse::hello() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SayHelloResponse.hello)
  return _internal_hello();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SayHelloResponse::set_hello(ArgT0&& arg0, ArgT... args) {
 
 hello_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SayHelloResponse.hello)
}
inline std::string* SayHelloResponse::mutable_hello() {
  std::string* _s = _internal_mutable_hello();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SayHelloResponse.hello)
  return _s;
}
inline const std::string& SayHelloResponse::_internal_hello() const {
  return hello_.Get();
}
inline void SayHelloResponse::_internal_set_hello(const std::string& value) {
  
  hello_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SayHelloResponse::_internal_mutable_hello() {
  
  return hello_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SayHelloResponse::release_hello() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SayHelloResponse.hello)
  return hello_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SayHelloResponse::set_allocated_hello(std::string* hello) {
  if (hello != nullptr) {
    
  } else {
    
  }
  hello_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hello,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hello_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hello_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SayHelloResponse.hello)
}

// .google.protobuf.Any data = 2;
inline bool SayHelloResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool SayHelloResponse::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SayHelloResponse::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SayHelloResponse::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SayHelloResponse.data)
  return _internal_data();
}
inline void SayHelloResponse::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Any* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.SayHelloResponse.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloResponse::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SayHelloResponse.data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SayHelloResponse::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SayHelloResponse.data)
  return _msg;
}
inline void SayHelloResponse::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SayHelloResponse.data)
}

// -------------------------------------------------------------------

// InvokeServiceRequest

// string id = 1;
inline void InvokeServiceRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& InvokeServiceRequest::id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeServiceRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeServiceRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.InvokeServiceRequest.id)
}
inline std::string* InvokeServiceRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeServiceRequest.id)
  return _s;
}
inline const std::string& InvokeServiceRequest::_internal_id() const {
  return id_.Get();
}
inline void InvokeServiceRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeServiceRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeServiceRequest::release_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeServiceRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeServiceRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeServiceRequest.id)
}

// .spec.proto.runtime.v1.CommonInvokeRequest message = 3;
inline bool InvokeServiceRequest::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool InvokeServiceRequest::has_message() const {
  return _internal_has_message();
}
inline void InvokeServiceRequest::clear_message() {
  if (GetArenaForAllocation() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::spec::proto::runtime::v1::CommonInvokeRequest& InvokeServiceRequest::_internal_message() const {
  const ::spec::proto::runtime::v1::CommonInvokeRequest* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::CommonInvokeRequest&>(
      ::spec::proto::runtime::v1::_CommonInvokeRequest_default_instance_);
}
inline const ::spec::proto::runtime::v1::CommonInvokeRequest& InvokeServiceRequest::message() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeServiceRequest.message)
  return _internal_message();
}
inline void InvokeServiceRequest::unsafe_arena_set_allocated_message(
    ::spec::proto::runtime::v1::CommonInvokeRequest* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.InvokeServiceRequest.message)
}
inline ::spec::proto::runtime::v1::CommonInvokeRequest* InvokeServiceRequest::release_message() {
  
  ::spec::proto::runtime::v1::CommonInvokeRequest* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::CommonInvokeRequest* InvokeServiceRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeServiceRequest.message)
  
  ::spec::proto::runtime::v1::CommonInvokeRequest* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::CommonInvokeRequest* InvokeServiceRequest::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::CommonInvokeRequest>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::spec::proto::runtime::v1::CommonInvokeRequest* InvokeServiceRequest::mutable_message() {
  ::spec::proto::runtime::v1::CommonInvokeRequest* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeServiceRequest.message)
  return _msg;
}
inline void InvokeServiceRequest::set_allocated_message(::spec::proto::runtime::v1::CommonInvokeRequest* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::CommonInvokeRequest>::GetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeServiceRequest.message)
}

// -------------------------------------------------------------------

// CommonInvokeRequest

// string method = 1;
inline void CommonInvokeRequest::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& CommonInvokeRequest::method() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.CommonInvokeRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonInvokeRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.CommonInvokeRequest.method)
}
inline std::string* CommonInvokeRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.CommonInvokeRequest.method)
  return _s;
}
inline const std::string& CommonInvokeRequest::_internal_method() const {
  return method_.Get();
}
inline void CommonInvokeRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonInvokeRequest::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonInvokeRequest::release_method() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.CommonInvokeRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommonInvokeRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.CommonInvokeRequest.method)
}

// .google.protobuf.Any data = 2;
inline bool CommonInvokeRequest::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool CommonInvokeRequest::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonInvokeRequest::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CommonInvokeRequest::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.CommonInvokeRequest.data)
  return _internal_data();
}
inline void CommonInvokeRequest::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Any* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.CommonInvokeRequest.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonInvokeRequest::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonInvokeRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.CommonInvokeRequest.data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonInvokeRequest::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CommonInvokeRequest::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.CommonInvokeRequest.data)
  return _msg;
}
inline void CommonInvokeRequest::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.CommonInvokeRequest.data)
}

// string content_type = 3;
inline void CommonInvokeRequest::clear_content_type() {
  content_type_.ClearToEmpty();
}
inline const std::string& CommonInvokeRequest::content_type() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.CommonInvokeRequest.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonInvokeRequest::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.CommonInvokeRequest.content_type)
}
inline std::string* CommonInvokeRequest::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.CommonInvokeRequest.content_type)
  return _s;
}
inline const std::string& CommonInvokeRequest::_internal_content_type() const {
  return content_type_.Get();
}
inline void CommonInvokeRequest::_internal_set_content_type(const std::string& value) {
  
  content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonInvokeRequest::_internal_mutable_content_type() {
  
  return content_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonInvokeRequest::release_content_type() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.CommonInvokeRequest.content_type)
  return content_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommonInvokeRequest::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  content_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.CommonInvokeRequest.content_type)
}

// .spec.proto.runtime.v1.HTTPExtension http_extension = 4;
inline bool CommonInvokeRequest::_internal_has_http_extension() const {
  return this != internal_default_instance() && http_extension_ != nullptr;
}
inline bool CommonInvokeRequest::has_http_extension() const {
  return _internal_has_http_extension();
}
inline void CommonInvokeRequest::clear_http_extension() {
  if (GetArenaForAllocation() == nullptr && http_extension_ != nullptr) {
    delete http_extension_;
  }
  http_extension_ = nullptr;
}
inline const ::spec::proto::runtime::v1::HTTPExtension& CommonInvokeRequest::_internal_http_extension() const {
  const ::spec::proto::runtime::v1::HTTPExtension* p = http_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::HTTPExtension&>(
      ::spec::proto::runtime::v1::_HTTPExtension_default_instance_);
}
inline const ::spec::proto::runtime::v1::HTTPExtension& CommonInvokeRequest::http_extension() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.CommonInvokeRequest.http_extension)
  return _internal_http_extension();
}
inline void CommonInvokeRequest::unsafe_arena_set_allocated_http_extension(
    ::spec::proto::runtime::v1::HTTPExtension* http_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(http_extension_);
  }
  http_extension_ = http_extension;
  if (http_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.CommonInvokeRequest.http_extension)
}
inline ::spec::proto::runtime::v1::HTTPExtension* CommonInvokeRequest::release_http_extension() {
  
  ::spec::proto::runtime::v1::HTTPExtension* temp = http_extension_;
  http_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::HTTPExtension* CommonInvokeRequest::unsafe_arena_release_http_extension() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.CommonInvokeRequest.http_extension)
  
  ::spec::proto::runtime::v1::HTTPExtension* temp = http_extension_;
  http_extension_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::HTTPExtension* CommonInvokeRequest::_internal_mutable_http_extension() {
  
  if (http_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::HTTPExtension>(GetArenaForAllocation());
    http_extension_ = p;
  }
  return http_extension_;
}
inline ::spec::proto::runtime::v1::HTTPExtension* CommonInvokeRequest::mutable_http_extension() {
  ::spec::proto::runtime::v1::HTTPExtension* _msg = _internal_mutable_http_extension();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.CommonInvokeRequest.http_extension)
  return _msg;
}
inline void CommonInvokeRequest::set_allocated_http_extension(::spec::proto::runtime::v1::HTTPExtension* http_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete http_extension_;
  }
  if (http_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::HTTPExtension>::GetOwningArena(http_extension);
    if (message_arena != submessage_arena) {
      http_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, http_extension, submessage_arena);
    }
    
  } else {
    
  }
  http_extension_ = http_extension;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.CommonInvokeRequest.http_extension)
}

// -------------------------------------------------------------------

// HTTPExtension

// .spec.proto.runtime.v1.HTTPExtension.Verb verb = 1;
inline void HTTPExtension::clear_verb() {
  verb_ = 0;
}
inline ::spec::proto::runtime::v1::HTTPExtension_Verb HTTPExtension::_internal_verb() const {
  return static_cast< ::spec::proto::runtime::v1::HTTPExtension_Verb >(verb_);
}
inline ::spec::proto::runtime::v1::HTTPExtension_Verb HTTPExtension::verb() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.HTTPExtension.verb)
  return _internal_verb();
}
inline void HTTPExtension::_internal_set_verb(::spec::proto::runtime::v1::HTTPExtension_Verb value) {
  
  verb_ = value;
}
inline void HTTPExtension::set_verb(::spec::proto::runtime::v1::HTTPExtension_Verb value) {
  _internal_set_verb(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.HTTPExtension.verb)
}

// string querystring = 2;
inline void HTTPExtension::clear_querystring() {
  querystring_.ClearToEmpty();
}
inline const std::string& HTTPExtension::querystring() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.HTTPExtension.querystring)
  return _internal_querystring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HTTPExtension::set_querystring(ArgT0&& arg0, ArgT... args) {
 
 querystring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.HTTPExtension.querystring)
}
inline std::string* HTTPExtension::mutable_querystring() {
  std::string* _s = _internal_mutable_querystring();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.HTTPExtension.querystring)
  return _s;
}
inline const std::string& HTTPExtension::_internal_querystring() const {
  return querystring_.Get();
}
inline void HTTPExtension::_internal_set_querystring(const std::string& value) {
  
  querystring_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HTTPExtension::_internal_mutable_querystring() {
  
  return querystring_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HTTPExtension::release_querystring() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.HTTPExtension.querystring)
  return querystring_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HTTPExtension::set_allocated_querystring(std::string* querystring) {
  if (querystring != nullptr) {
    
  } else {
    
  }
  querystring_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), querystring,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (querystring_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    querystring_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.HTTPExtension.querystring)
}

// -------------------------------------------------------------------

// InvokeResponse

// .google.protobuf.Any data = 1;
inline bool InvokeResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool InvokeResponse::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& InvokeResponse::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& InvokeResponse::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeResponse.data)
  return _internal_data();
}
inline void InvokeResponse::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Any* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.InvokeResponse.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InvokeResponse::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InvokeResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeResponse.data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InvokeResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InvokeResponse::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeResponse.data)
  return _msg;
}
inline void InvokeResponse::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Any* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeResponse.data)
}

// string content_type = 2;
inline void InvokeResponse::clear_content_type() {
  content_type_.ClearToEmpty();
}
inline const std::string& InvokeResponse::content_type() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeResponse.content_type)
  return _internal_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeResponse::set_content_type(ArgT0&& arg0, ArgT... args) {
 
 content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.InvokeResponse.content_type)
}
inline std::string* InvokeResponse::mutable_content_type() {
  std::string* _s = _internal_mutable_content_type();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeResponse.content_type)
  return _s;
}
inline const std::string& InvokeResponse::_internal_content_type() const {
  return content_type_.Get();
}
inline void InvokeResponse::_internal_set_content_type(const std::string& value) {
  
  content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeResponse::_internal_mutable_content_type() {
  
  return content_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeResponse::release_content_type() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeResponse.content_type)
  return content_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeResponse::set_allocated_content_type(std::string* content_type) {
  if (content_type != nullptr) {
    
  } else {
    
  }
  content_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeResponse.content_type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ConfigurationItem

// string key = 1;
inline void ConfigurationItem::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& ConfigurationItem::key() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ConfigurationItem.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationItem::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ConfigurationItem.key)
}
inline std::string* ConfigurationItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ConfigurationItem.key)
  return _s;
}
inline const std::string& ConfigurationItem::_internal_key() const {
  return key_.Get();
}
inline void ConfigurationItem::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::release_key() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ConfigurationItem.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigurationItem::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ConfigurationItem.key)
}

// string content = 2;
inline void ConfigurationItem::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ConfigurationItem::content() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ConfigurationItem.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationItem::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ConfigurationItem.content)
}
inline std::string* ConfigurationItem::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ConfigurationItem.content)
  return _s;
}
inline const std::string& ConfigurationItem::_internal_content() const {
  return content_.Get();
}
inline void ConfigurationItem::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::release_content() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ConfigurationItem.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigurationItem::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ConfigurationItem.content)
}

// string group = 3;
inline void ConfigurationItem::clear_group() {
  group_.ClearToEmpty();
}
inline const std::string& ConfigurationItem::group() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ConfigurationItem.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationItem::set_group(ArgT0&& arg0, ArgT... args) {
 
 group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ConfigurationItem.group)
}
inline std::string* ConfigurationItem::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ConfigurationItem.group)
  return _s;
}
inline const std::string& ConfigurationItem::_internal_group() const {
  return group_.Get();
}
inline void ConfigurationItem::_internal_set_group(const std::string& value) {
  
  group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::_internal_mutable_group() {
  
  return group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::release_group() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ConfigurationItem.group)
  return group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigurationItem::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ConfigurationItem.group)
}

// string label = 4;
inline void ConfigurationItem::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& ConfigurationItem::label() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ConfigurationItem.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigurationItem::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ConfigurationItem.label)
}
inline std::string* ConfigurationItem::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ConfigurationItem.label)
  return _s;
}
inline const std::string& ConfigurationItem::_internal_label() const {
  return label_.Get();
}
inline void ConfigurationItem::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigurationItem::release_label() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ConfigurationItem.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigurationItem::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ConfigurationItem.label)
}

// map<string, string> tags = 5;
inline int ConfigurationItem::_internal_tags_size() const {
  return tags_.size();
}
inline int ConfigurationItem::tags_size() const {
  return _internal_tags_size();
}
inline void ConfigurationItem::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigurationItem::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigurationItem::tags() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.ConfigurationItem.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigurationItem::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigurationItem::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.ConfigurationItem.tags)
  return _internal_mutable_tags();
}

// map<string, string> metadata = 6;
inline int ConfigurationItem::_internal_metadata_size() const {
  return metadata_.size();
}
inline int ConfigurationItem::metadata_size() const {
  return _internal_metadata_size();
}
inline void ConfigurationItem::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigurationItem::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigurationItem::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.ConfigurationItem.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigurationItem::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigurationItem::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.ConfigurationItem.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetConfigurationRequest

// string store_name = 1;
inline void GetConfigurationRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& GetConfigurationRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConfigurationRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.store_name)
}
inline std::string* GetConfigurationRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetConfigurationRequest.store_name)
  return _s;
}
inline const std::string& GetConfigurationRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void GetConfigurationRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetConfigurationRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetConfigurationRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetConfigurationRequest.store_name)
}

// string app_id = 2;
inline void GetConfigurationRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& GetConfigurationRequest::app_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConfigurationRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.app_id)
}
inline std::string* GetConfigurationRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetConfigurationRequest.app_id)
  return _s;
}
inline const std::string& GetConfigurationRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void GetConfigurationRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetConfigurationRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetConfigurationRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetConfigurationRequest.app_id)
}

// string group = 3;
inline void GetConfigurationRequest::clear_group() {
  group_.ClearToEmpty();
}
inline const std::string& GetConfigurationRequest::group() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationRequest.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConfigurationRequest::set_group(ArgT0&& arg0, ArgT... args) {
 
 group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.group)
}
inline std::string* GetConfigurationRequest::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetConfigurationRequest.group)
  return _s;
}
inline const std::string& GetConfigurationRequest::_internal_group() const {
  return group_.Get();
}
inline void GetConfigurationRequest::_internal_set_group(const std::string& value) {
  
  group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::_internal_mutable_group() {
  
  return group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::release_group() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetConfigurationRequest.group)
  return group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetConfigurationRequest::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetConfigurationRequest.group)
}

// string label = 4;
inline void GetConfigurationRequest::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& GetConfigurationRequest::label() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConfigurationRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.label)
}
inline std::string* GetConfigurationRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetConfigurationRequest.label)
  return _s;
}
inline const std::string& GetConfigurationRequest::_internal_label() const {
  return label_.Get();
}
inline void GetConfigurationRequest::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetConfigurationRequest::release_label() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetConfigurationRequest.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetConfigurationRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetConfigurationRequest.label)
}

// repeated string keys = 5;
inline int GetConfigurationRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int GetConfigurationRequest::keys_size() const {
  return _internal_keys_size();
}
inline void GetConfigurationRequest::clear_keys() {
  keys_.Clear();
}
inline std::string* GetConfigurationRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:spec.proto.runtime.v1.GetConfigurationRequest.keys)
  return _s;
}
inline const std::string& GetConfigurationRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& GetConfigurationRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationRequest.keys)
  return _internal_keys(index);
}
inline std::string* GetConfigurationRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetConfigurationRequest.keys)
  return keys_.Mutable(index);
}
inline void GetConfigurationRequest::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline void GetConfigurationRequest::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline void GetConfigurationRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline void GetConfigurationRequest::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline std::string* GetConfigurationRequest::_internal_add_keys() {
  return keys_.Add();
}
inline void GetConfigurationRequest::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline void GetConfigurationRequest::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline void GetConfigurationRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline void GetConfigurationRequest::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spec.proto.runtime.v1.GetConfigurationRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConfigurationRequest::keys() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.GetConfigurationRequest.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConfigurationRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.GetConfigurationRequest.keys)
  return &keys_;
}

// map<string, string> metadata = 6;
inline int GetConfigurationRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int GetConfigurationRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetConfigurationRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetConfigurationRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetConfigurationRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.GetConfigurationRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetConfigurationRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetConfigurationRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.GetConfigurationRequest.metadata)
  return _internal_mutable_metadata();
}

// bool subscribe_update = 7;
inline void GetConfigurationRequest::clear_subscribe_update() {
  subscribe_update_ = false;
}
inline bool GetConfigurationRequest::_internal_subscribe_update() const {
  return subscribe_update_;
}
inline bool GetConfigurationRequest::subscribe_update() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationRequest.subscribe_update)
  return _internal_subscribe_update();
}
inline void GetConfigurationRequest::_internal_set_subscribe_update(bool value) {
  
  subscribe_update_ = value;
}
inline void GetConfigurationRequest::set_subscribe_update(bool value) {
  _internal_set_subscribe_update(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetConfigurationRequest.subscribe_update)
}

// -------------------------------------------------------------------

// GetConfigurationResponse

// repeated .spec.proto.runtime.v1.ConfigurationItem items = 1;
inline int GetConfigurationResponse::_internal_items_size() const {
  return items_.size();
}
inline int GetConfigurationResponse::items_size() const {
  return _internal_items_size();
}
inline void GetConfigurationResponse::clear_items() {
  items_.Clear();
}
inline ::spec::proto::runtime::v1::ConfigurationItem* GetConfigurationResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetConfigurationResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >*
GetConfigurationResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.GetConfigurationResponse.items)
  return &items_;
}
inline const ::spec::proto::runtime::v1::ConfigurationItem& GetConfigurationResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::spec::proto::runtime::v1::ConfigurationItem& GetConfigurationResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetConfigurationResponse.items)
  return _internal_items(index);
}
inline ::spec::proto::runtime::v1::ConfigurationItem* GetConfigurationResponse::_internal_add_items() {
  return items_.Add();
}
inline ::spec::proto::runtime::v1::ConfigurationItem* GetConfigurationResponse::add_items() {
  ::spec::proto::runtime::v1::ConfigurationItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.GetConfigurationResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >&
GetConfigurationResponse::items() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.GetConfigurationResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SubscribeConfigurationRequest

// string store_name = 1;
inline void SubscribeConfigurationRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& SubscribeConfigurationRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeConfigurationRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationRequest.store_name)
}
inline std::string* SubscribeConfigurationRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationRequest.store_name)
  return _s;
}
inline const std::string& SubscribeConfigurationRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void SubscribeConfigurationRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SubscribeConfigurationRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeConfigurationRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SubscribeConfigurationRequest.store_name)
}

// string app_id = 2;
inline void SubscribeConfigurationRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& SubscribeConfigurationRequest::app_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeConfigurationRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationRequest.app_id)
}
inline std::string* SubscribeConfigurationRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationRequest.app_id)
  return _s;
}
inline const std::string& SubscribeConfigurationRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void SubscribeConfigurationRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SubscribeConfigurationRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeConfigurationRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SubscribeConfigurationRequest.app_id)
}

// string group = 3;
inline void SubscribeConfigurationRequest::clear_group() {
  group_.ClearToEmpty();
}
inline const std::string& SubscribeConfigurationRequest::group() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationRequest.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeConfigurationRequest::set_group(ArgT0&& arg0, ArgT... args) {
 
 group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationRequest.group)
}
inline std::string* SubscribeConfigurationRequest::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationRequest.group)
  return _s;
}
inline const std::string& SubscribeConfigurationRequest::_internal_group() const {
  return group_.Get();
}
inline void SubscribeConfigurationRequest::_internal_set_group(const std::string& value) {
  
  group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::_internal_mutable_group() {
  
  return group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::release_group() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SubscribeConfigurationRequest.group)
  return group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeConfigurationRequest::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SubscribeConfigurationRequest.group)
}

// string label = 4;
inline void SubscribeConfigurationRequest::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& SubscribeConfigurationRequest::label() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeConfigurationRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationRequest.label)
}
inline std::string* SubscribeConfigurationRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationRequest.label)
  return _s;
}
inline const std::string& SubscribeConfigurationRequest::_internal_label() const {
  return label_.Get();
}
inline void SubscribeConfigurationRequest::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationRequest::release_label() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SubscribeConfigurationRequest.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeConfigurationRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SubscribeConfigurationRequest.label)
}

// repeated string keys = 5;
inline int SubscribeConfigurationRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int SubscribeConfigurationRequest::keys_size() const {
  return _internal_keys_size();
}
inline void SubscribeConfigurationRequest::clear_keys() {
  keys_.Clear();
}
inline std::string* SubscribeConfigurationRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
  return _s;
}
inline const std::string& SubscribeConfigurationRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& SubscribeConfigurationRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
  return _internal_keys(index);
}
inline std::string* SubscribeConfigurationRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
  return keys_.Mutable(index);
}
inline void SubscribeConfigurationRequest::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline void SubscribeConfigurationRequest::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline void SubscribeConfigurationRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline void SubscribeConfigurationRequest::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline std::string* SubscribeConfigurationRequest::_internal_add_keys() {
  return keys_.Add();
}
inline void SubscribeConfigurationRequest::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline void SubscribeConfigurationRequest::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline void SubscribeConfigurationRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline void SubscribeConfigurationRequest::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubscribeConfigurationRequest::keys() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubscribeConfigurationRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.SubscribeConfigurationRequest.keys)
  return &keys_;
}

// map<string, string> metadata = 6;
inline int SubscribeConfigurationRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int SubscribeConfigurationRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void SubscribeConfigurationRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SubscribeConfigurationRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SubscribeConfigurationRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.SubscribeConfigurationRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SubscribeConfigurationRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SubscribeConfigurationRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.SubscribeConfigurationRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// SubscribeConfigurationResponse

// string store_name = 1;
inline void SubscribeConfigurationResponse::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& SubscribeConfigurationResponse::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationResponse.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeConfigurationResponse::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationResponse.store_name)
}
inline std::string* SubscribeConfigurationResponse::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationResponse.store_name)
  return _s;
}
inline const std::string& SubscribeConfigurationResponse::_internal_store_name() const {
  return store_name_.Get();
}
inline void SubscribeConfigurationResponse::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationResponse::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationResponse::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SubscribeConfigurationResponse.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeConfigurationResponse::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SubscribeConfigurationResponse.store_name)
}

// string app_id = 2;
inline void SubscribeConfigurationResponse::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& SubscribeConfigurationResponse::app_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationResponse.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeConfigurationResponse::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SubscribeConfigurationResponse.app_id)
}
inline std::string* SubscribeConfigurationResponse::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationResponse.app_id)
  return _s;
}
inline const std::string& SubscribeConfigurationResponse::_internal_app_id() const {
  return app_id_.Get();
}
inline void SubscribeConfigurationResponse::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationResponse::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeConfigurationResponse::release_app_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SubscribeConfigurationResponse.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeConfigurationResponse::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SubscribeConfigurationResponse.app_id)
}

// repeated .spec.proto.runtime.v1.ConfigurationItem items = 3;
inline int SubscribeConfigurationResponse::_internal_items_size() const {
  return items_.size();
}
inline int SubscribeConfigurationResponse::items_size() const {
  return _internal_items_size();
}
inline void SubscribeConfigurationResponse::clear_items() {
  items_.Clear();
}
inline ::spec::proto::runtime::v1::ConfigurationItem* SubscribeConfigurationResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SubscribeConfigurationResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >*
SubscribeConfigurationResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.SubscribeConfigurationResponse.items)
  return &items_;
}
inline const ::spec::proto::runtime::v1::ConfigurationItem& SubscribeConfigurationResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::spec::proto::runtime::v1::ConfigurationItem& SubscribeConfigurationResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SubscribeConfigurationResponse.items)
  return _internal_items(index);
}
inline ::spec::proto::runtime::v1::ConfigurationItem* SubscribeConfigurationResponse::_internal_add_items() {
  return items_.Add();
}
inline ::spec::proto::runtime::v1::ConfigurationItem* SubscribeConfigurationResponse::add_items() {
  ::spec::proto::runtime::v1::ConfigurationItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.SubscribeConfigurationResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >&
SubscribeConfigurationResponse::items() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.SubscribeConfigurationResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SaveConfigurationRequest

// string store_name = 1;
inline void SaveConfigurationRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& SaveConfigurationRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SaveConfigurationRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveConfigurationRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SaveConfigurationRequest.store_name)
}
inline std::string* SaveConfigurationRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SaveConfigurationRequest.store_name)
  return _s;
}
inline const std::string& SaveConfigurationRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void SaveConfigurationRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SaveConfigurationRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SaveConfigurationRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SaveConfigurationRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SaveConfigurationRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SaveConfigurationRequest.store_name)
}

// string app_id = 2;
inline void SaveConfigurationRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& SaveConfigurationRequest::app_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SaveConfigurationRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveConfigurationRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SaveConfigurationRequest.app_id)
}
inline std::string* SaveConfigurationRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SaveConfigurationRequest.app_id)
  return _s;
}
inline const std::string& SaveConfigurationRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void SaveConfigurationRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SaveConfigurationRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SaveConfigurationRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SaveConfigurationRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SaveConfigurationRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SaveConfigurationRequest.app_id)
}

// repeated .spec.proto.runtime.v1.ConfigurationItem items = 3;
inline int SaveConfigurationRequest::_internal_items_size() const {
  return items_.size();
}
inline int SaveConfigurationRequest::items_size() const {
  return _internal_items_size();
}
inline void SaveConfigurationRequest::clear_items() {
  items_.Clear();
}
inline ::spec::proto::runtime::v1::ConfigurationItem* SaveConfigurationRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SaveConfigurationRequest.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >*
SaveConfigurationRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.SaveConfigurationRequest.items)
  return &items_;
}
inline const ::spec::proto::runtime::v1::ConfigurationItem& SaveConfigurationRequest::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::spec::proto::runtime::v1::ConfigurationItem& SaveConfigurationRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SaveConfigurationRequest.items)
  return _internal_items(index);
}
inline ::spec::proto::runtime::v1::ConfigurationItem* SaveConfigurationRequest::_internal_add_items() {
  return items_.Add();
}
inline ::spec::proto::runtime::v1::ConfigurationItem* SaveConfigurationRequest::add_items() {
  ::spec::proto::runtime::v1::ConfigurationItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.SaveConfigurationRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::ConfigurationItem >&
SaveConfigurationRequest::items() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.SaveConfigurationRequest.items)
  return items_;
}

// map<string, string> metadata = 4;
inline int SaveConfigurationRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int SaveConfigurationRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void SaveConfigurationRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SaveConfigurationRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SaveConfigurationRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.SaveConfigurationRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SaveConfigurationRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SaveConfigurationRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.SaveConfigurationRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteConfigurationRequest

// string store_name = 1;
inline void DeleteConfigurationRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& DeleteConfigurationRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteConfigurationRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConfigurationRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteConfigurationRequest.store_name)
}
inline std::string* DeleteConfigurationRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteConfigurationRequest.store_name)
  return _s;
}
inline const std::string& DeleteConfigurationRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void DeleteConfigurationRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteConfigurationRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteConfigurationRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteConfigurationRequest.store_name)
}

// string app_id = 2;
inline void DeleteConfigurationRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& DeleteConfigurationRequest::app_id() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteConfigurationRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConfigurationRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteConfigurationRequest.app_id)
}
inline std::string* DeleteConfigurationRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteConfigurationRequest.app_id)
  return _s;
}
inline const std::string& DeleteConfigurationRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void DeleteConfigurationRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteConfigurationRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteConfigurationRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteConfigurationRequest.app_id)
}

// string group = 3;
inline void DeleteConfigurationRequest::clear_group() {
  group_.ClearToEmpty();
}
inline const std::string& DeleteConfigurationRequest::group() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteConfigurationRequest.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConfigurationRequest::set_group(ArgT0&& arg0, ArgT... args) {
 
 group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteConfigurationRequest.group)
}
inline std::string* DeleteConfigurationRequest::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteConfigurationRequest.group)
  return _s;
}
inline const std::string& DeleteConfigurationRequest::_internal_group() const {
  return group_.Get();
}
inline void DeleteConfigurationRequest::_internal_set_group(const std::string& value) {
  
  group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::_internal_mutable_group() {
  
  return group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::release_group() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteConfigurationRequest.group)
  return group_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteConfigurationRequest::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteConfigurationRequest.group)
}

// string label = 4;
inline void DeleteConfigurationRequest::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& DeleteConfigurationRequest::label() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteConfigurationRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConfigurationRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteConfigurationRequest.label)
}
inline std::string* DeleteConfigurationRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteConfigurationRequest.label)
  return _s;
}
inline const std::string& DeleteConfigurationRequest::_internal_label() const {
  return label_.Get();
}
inline void DeleteConfigurationRequest::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteConfigurationRequest::release_label() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteConfigurationRequest.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteConfigurationRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteConfigurationRequest.label)
}

// repeated string keys = 5;
inline int DeleteConfigurationRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int DeleteConfigurationRequest::keys_size() const {
  return _internal_keys_size();
}
inline void DeleteConfigurationRequest::clear_keys() {
  keys_.Clear();
}
inline std::string* DeleteConfigurationRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
  return _s;
}
inline const std::string& DeleteConfigurationRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& DeleteConfigurationRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
  return _internal_keys(index);
}
inline std::string* DeleteConfigurationRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
  return keys_.Mutable(index);
}
inline void DeleteConfigurationRequest::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline void DeleteConfigurationRequest::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline void DeleteConfigurationRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline void DeleteConfigurationRequest::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline std::string* DeleteConfigurationRequest::_internal_add_keys() {
  return keys_.Add();
}
inline void DeleteConfigurationRequest::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline void DeleteConfigurationRequest::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline void DeleteConfigurationRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline void DeleteConfigurationRequest::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteConfigurationRequest::keys() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteConfigurationRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.DeleteConfigurationRequest.keys)
  return &keys_;
}

// map<string, string> metadata = 6;
inline int DeleteConfigurationRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int DeleteConfigurationRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void DeleteConfigurationRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteConfigurationRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteConfigurationRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.DeleteConfigurationRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteConfigurationRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteConfigurationRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.DeleteConfigurationRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetStateRequest

// string store_name = 1;
inline void GetStateRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& GetStateRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetStateRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStateRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetStateRequest.store_name)
}
inline std::string* GetStateRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetStateRequest.store_name)
  return _s;
}
inline const std::string& GetStateRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void GetStateRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetStateRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetStateRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetStateRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetStateRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetStateRequest.store_name)
}

// string key = 2;
inline void GetStateRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& GetStateRequest::key() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetStateRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStateRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetStateRequest.key)
}
inline std::string* GetStateRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetStateRequest.key)
  return _s;
}
inline const std::string& GetStateRequest::_internal_key() const {
  return key_.Get();
}
inline void GetStateRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetStateRequest::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetStateRequest::release_key() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetStateRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetStateRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetStateRequest.key)
}

// .spec.proto.runtime.v1.StateOptions.StateConsistency consistency = 3;
inline void GetStateRequest::clear_consistency() {
  consistency_ = 0;
}
inline ::spec::proto::runtime::v1::StateOptions_StateConsistency GetStateRequest::_internal_consistency() const {
  return static_cast< ::spec::proto::runtime::v1::StateOptions_StateConsistency >(consistency_);
}
inline ::spec::proto::runtime::v1::StateOptions_StateConsistency GetStateRequest::consistency() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetStateRequest.consistency)
  return _internal_consistency();
}
inline void GetStateRequest::_internal_set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value) {
  
  consistency_ = value;
}
inline void GetStateRequest::set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetStateRequest.consistency)
}

// map<string, string> metadata = 4;
inline int GetStateRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int GetStateRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetStateRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetStateRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetStateRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.GetStateRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetStateRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetStateRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.GetStateRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetBulkStateRequest

// string store_name = 1;
inline void GetBulkStateRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& GetBulkStateRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetBulkStateRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBulkStateRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetBulkStateRequest.store_name)
}
inline std::string* GetBulkStateRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetBulkStateRequest.store_name)
  return _s;
}
inline const std::string& GetBulkStateRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void GetBulkStateRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBulkStateRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBulkStateRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetBulkStateRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBulkStateRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetBulkStateRequest.store_name)
}

// repeated string keys = 2;
inline int GetBulkStateRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int GetBulkStateRequest::keys_size() const {
  return _internal_keys_size();
}
inline void GetBulkStateRequest::clear_keys() {
  keys_.Clear();
}
inline std::string* GetBulkStateRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:spec.proto.runtime.v1.GetBulkStateRequest.keys)
  return _s;
}
inline const std::string& GetBulkStateRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& GetBulkStateRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetBulkStateRequest.keys)
  return _internal_keys(index);
}
inline std::string* GetBulkStateRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetBulkStateRequest.keys)
  return keys_.Mutable(index);
}
inline void GetBulkStateRequest::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline void GetBulkStateRequest::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline void GetBulkStateRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline void GetBulkStateRequest::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline std::string* GetBulkStateRequest::_internal_add_keys() {
  return keys_.Add();
}
inline void GetBulkStateRequest::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline void GetBulkStateRequest::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline void GetBulkStateRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline void GetBulkStateRequest::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:spec.proto.runtime.v1.GetBulkStateRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetBulkStateRequest::keys() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.GetBulkStateRequest.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetBulkStateRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.GetBulkStateRequest.keys)
  return &keys_;
}

// int32 parallelism = 3;
inline void GetBulkStateRequest::clear_parallelism() {
  parallelism_ = 0;
}
inline int32_t GetBulkStateRequest::_internal_parallelism() const {
  return parallelism_;
}
inline int32_t GetBulkStateRequest::parallelism() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetBulkStateRequest.parallelism)
  return _internal_parallelism();
}
inline void GetBulkStateRequest::_internal_set_parallelism(int32_t value) {
  
  parallelism_ = value;
}
inline void GetBulkStateRequest::set_parallelism(int32_t value) {
  _internal_set_parallelism(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetBulkStateRequest.parallelism)
}

// map<string, string> metadata = 4;
inline int GetBulkStateRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int GetBulkStateRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetBulkStateRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetBulkStateRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetBulkStateRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.GetBulkStateRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetBulkStateRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetBulkStateRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.GetBulkStateRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// GetBulkStateResponse

// repeated .spec.proto.runtime.v1.BulkStateItem items = 1;
inline int GetBulkStateResponse::_internal_items_size() const {
  return items_.size();
}
inline int GetBulkStateResponse::items_size() const {
  return _internal_items_size();
}
inline void GetBulkStateResponse::clear_items() {
  items_.Clear();
}
inline ::spec::proto::runtime::v1::BulkStateItem* GetBulkStateResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetBulkStateResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::BulkStateItem >*
GetBulkStateResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.GetBulkStateResponse.items)
  return &items_;
}
inline const ::spec::proto::runtime::v1::BulkStateItem& GetBulkStateResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::spec::proto::runtime::v1::BulkStateItem& GetBulkStateResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetBulkStateResponse.items)
  return _internal_items(index);
}
inline ::spec::proto::runtime::v1::BulkStateItem* GetBulkStateResponse::_internal_add_items() {
  return items_.Add();
}
inline ::spec::proto::runtime::v1::BulkStateItem* GetBulkStateResponse::add_items() {
  ::spec::proto::runtime::v1::BulkStateItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.GetBulkStateResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::BulkStateItem >&
GetBulkStateResponse::items() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.GetBulkStateResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BulkStateItem

// string key = 1;
inline void BulkStateItem::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& BulkStateItem::key() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.BulkStateItem.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkStateItem::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.BulkStateItem.key)
}
inline std::string* BulkStateItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.BulkStateItem.key)
  return _s;
}
inline const std::string& BulkStateItem::_internal_key() const {
  return key_.Get();
}
inline void BulkStateItem::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BulkStateItem::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BulkStateItem::release_key() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.BulkStateItem.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BulkStateItem::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.BulkStateItem.key)
}

// bytes data = 2;
inline void BulkStateItem::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& BulkStateItem::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.BulkStateItem.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkStateItem::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.BulkStateItem.data)
}
inline std::string* BulkStateItem::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.BulkStateItem.data)
  return _s;
}
inline const std::string& BulkStateItem::_internal_data() const {
  return data_.Get();
}
inline void BulkStateItem::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BulkStateItem::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BulkStateItem::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.BulkStateItem.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BulkStateItem::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.BulkStateItem.data)
}

// string etag = 3;
inline void BulkStateItem::clear_etag() {
  etag_.ClearToEmpty();
}
inline const std::string& BulkStateItem::etag() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.BulkStateItem.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkStateItem::set_etag(ArgT0&& arg0, ArgT... args) {
 
 etag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.BulkStateItem.etag)
}
inline std::string* BulkStateItem::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.BulkStateItem.etag)
  return _s;
}
inline const std::string& BulkStateItem::_internal_etag() const {
  return etag_.Get();
}
inline void BulkStateItem::_internal_set_etag(const std::string& value) {
  
  etag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BulkStateItem::_internal_mutable_etag() {
  
  return etag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BulkStateItem::release_etag() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.BulkStateItem.etag)
  return etag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BulkStateItem::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  etag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), etag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    etag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.BulkStateItem.etag)
}

// string error = 4;
inline void BulkStateItem::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& BulkStateItem::error() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.BulkStateItem.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BulkStateItem::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.BulkStateItem.error)
}
inline std::string* BulkStateItem::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.BulkStateItem.error)
  return _s;
}
inline const std::string& BulkStateItem::_internal_error() const {
  return error_.Get();
}
inline void BulkStateItem::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BulkStateItem::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BulkStateItem::release_error() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.BulkStateItem.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BulkStateItem::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.BulkStateItem.error)
}

// map<string, string> metadata = 5;
inline int BulkStateItem::_internal_metadata_size() const {
  return metadata_.size();
}
inline int BulkStateItem::metadata_size() const {
  return _internal_metadata_size();
}
inline void BulkStateItem::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BulkStateItem::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BulkStateItem::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.BulkStateItem.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BulkStateItem::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BulkStateItem::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.BulkStateItem.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetStateResponse

// bytes data = 1;
inline void GetStateResponse::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& GetStateResponse::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetStateResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStateResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetStateResponse.data)
}
inline std::string* GetStateResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetStateResponse.data)
  return _s;
}
inline const std::string& GetStateResponse::_internal_data() const {
  return data_.Get();
}
inline void GetStateResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetStateResponse::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetStateResponse::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetStateResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetStateResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetStateResponse.data)
}

// string etag = 2;
inline void GetStateResponse::clear_etag() {
  etag_.ClearToEmpty();
}
inline const std::string& GetStateResponse::etag() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.GetStateResponse.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStateResponse::set_etag(ArgT0&& arg0, ArgT... args) {
 
 etag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.GetStateResponse.etag)
}
inline std::string* GetStateResponse::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.GetStateResponse.etag)
  return _s;
}
inline const std::string& GetStateResponse::_internal_etag() const {
  return etag_.Get();
}
inline void GetStateResponse::_internal_set_etag(const std::string& value) {
  
  etag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetStateResponse::_internal_mutable_etag() {
  
  return etag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetStateResponse::release_etag() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.GetStateResponse.etag)
  return etag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetStateResponse::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    
  } else {
    
  }
  etag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), etag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    etag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.GetStateResponse.etag)
}

// map<string, string> metadata = 3;
inline int GetStateResponse::_internal_metadata_size() const {
  return metadata_.size();
}
inline int GetStateResponse::metadata_size() const {
  return _internal_metadata_size();
}
inline void GetStateResponse::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetStateResponse::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetStateResponse::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.GetStateResponse.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetStateResponse::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetStateResponse::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.GetStateResponse.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteStateRequest

// string store_name = 1;
inline void DeleteStateRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& DeleteStateRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteStateRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteStateRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteStateRequest.store_name)
}
inline std::string* DeleteStateRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteStateRequest.store_name)
  return _s;
}
inline const std::string& DeleteStateRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void DeleteStateRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteStateRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteStateRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteStateRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteStateRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteStateRequest.store_name)
}

// string key = 2;
inline void DeleteStateRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& DeleteStateRequest::key() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteStateRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteStateRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteStateRequest.key)
}
inline std::string* DeleteStateRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteStateRequest.key)
  return _s;
}
inline const std::string& DeleteStateRequest::_internal_key() const {
  return key_.Get();
}
inline void DeleteStateRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteStateRequest::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteStateRequest::release_key() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteStateRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteStateRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteStateRequest.key)
}

// .spec.proto.runtime.v1.Etag etag = 3;
inline bool DeleteStateRequest::_internal_has_etag() const {
  return this != internal_default_instance() && etag_ != nullptr;
}
inline bool DeleteStateRequest::has_etag() const {
  return _internal_has_etag();
}
inline void DeleteStateRequest::clear_etag() {
  if (GetArenaForAllocation() == nullptr && etag_ != nullptr) {
    delete etag_;
  }
  etag_ = nullptr;
}
inline const ::spec::proto::runtime::v1::Etag& DeleteStateRequest::_internal_etag() const {
  const ::spec::proto::runtime::v1::Etag* p = etag_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::Etag&>(
      ::spec::proto::runtime::v1::_Etag_default_instance_);
}
inline const ::spec::proto::runtime::v1::Etag& DeleteStateRequest::etag() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteStateRequest.etag)
  return _internal_etag();
}
inline void DeleteStateRequest::unsafe_arena_set_allocated_etag(
    ::spec::proto::runtime::v1::Etag* etag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(etag_);
  }
  etag_ = etag;
  if (etag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.DeleteStateRequest.etag)
}
inline ::spec::proto::runtime::v1::Etag* DeleteStateRequest::release_etag() {
  
  ::spec::proto::runtime::v1::Etag* temp = etag_;
  etag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::Etag* DeleteStateRequest::unsafe_arena_release_etag() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteStateRequest.etag)
  
  ::spec::proto::runtime::v1::Etag* temp = etag_;
  etag_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::Etag* DeleteStateRequest::_internal_mutable_etag() {
  
  if (etag_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::Etag>(GetArenaForAllocation());
    etag_ = p;
  }
  return etag_;
}
inline ::spec::proto::runtime::v1::Etag* DeleteStateRequest::mutable_etag() {
  ::spec::proto::runtime::v1::Etag* _msg = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteStateRequest.etag)
  return _msg;
}
inline void DeleteStateRequest::set_allocated_etag(::spec::proto::runtime::v1::Etag* etag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete etag_;
  }
  if (etag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::Etag>::GetOwningArena(etag);
    if (message_arena != submessage_arena) {
      etag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, etag, submessage_arena);
    }
    
  } else {
    
  }
  etag_ = etag;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteStateRequest.etag)
}

// .spec.proto.runtime.v1.StateOptions options = 4;
inline bool DeleteStateRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool DeleteStateRequest::has_options() const {
  return _internal_has_options();
}
inline void DeleteStateRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::spec::proto::runtime::v1::StateOptions& DeleteStateRequest::_internal_options() const {
  const ::spec::proto::runtime::v1::StateOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::StateOptions&>(
      ::spec::proto::runtime::v1::_StateOptions_default_instance_);
}
inline const ::spec::proto::runtime::v1::StateOptions& DeleteStateRequest::options() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteStateRequest.options)
  return _internal_options();
}
inline void DeleteStateRequest::unsafe_arena_set_allocated_options(
    ::spec::proto::runtime::v1::StateOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.DeleteStateRequest.options)
}
inline ::spec::proto::runtime::v1::StateOptions* DeleteStateRequest::release_options() {
  
  ::spec::proto::runtime::v1::StateOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::StateOptions* DeleteStateRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteStateRequest.options)
  
  ::spec::proto::runtime::v1::StateOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::StateOptions* DeleteStateRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::StateOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::spec::proto::runtime::v1::StateOptions* DeleteStateRequest::mutable_options() {
  ::spec::proto::runtime::v1::StateOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteStateRequest.options)
  return _msg;
}
inline void DeleteStateRequest::set_allocated_options(::spec::proto::runtime::v1::StateOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::StateOptions>::GetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteStateRequest.options)
}

// map<string, string> metadata = 5;
inline int DeleteStateRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int DeleteStateRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void DeleteStateRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteStateRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteStateRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.DeleteStateRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteStateRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteStateRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.DeleteStateRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// DeleteBulkStateRequest

// string store_name = 1;
inline void DeleteBulkStateRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& DeleteBulkStateRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteBulkStateRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteBulkStateRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.DeleteBulkStateRequest.store_name)
}
inline std::string* DeleteBulkStateRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteBulkStateRequest.store_name)
  return _s;
}
inline const std::string& DeleteBulkStateRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void DeleteBulkStateRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteBulkStateRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteBulkStateRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.DeleteBulkStateRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteBulkStateRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.DeleteBulkStateRequest.store_name)
}

// repeated .spec.proto.runtime.v1.StateItem states = 2;
inline int DeleteBulkStateRequest::_internal_states_size() const {
  return states_.size();
}
inline int DeleteBulkStateRequest::states_size() const {
  return _internal_states_size();
}
inline void DeleteBulkStateRequest::clear_states() {
  states_.Clear();
}
inline ::spec::proto::runtime::v1::StateItem* DeleteBulkStateRequest::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.DeleteBulkStateRequest.states)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >*
DeleteBulkStateRequest::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.DeleteBulkStateRequest.states)
  return &states_;
}
inline const ::spec::proto::runtime::v1::StateItem& DeleteBulkStateRequest::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::spec::proto::runtime::v1::StateItem& DeleteBulkStateRequest::states(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.DeleteBulkStateRequest.states)
  return _internal_states(index);
}
inline ::spec::proto::runtime::v1::StateItem* DeleteBulkStateRequest::_internal_add_states() {
  return states_.Add();
}
inline ::spec::proto::runtime::v1::StateItem* DeleteBulkStateRequest::add_states() {
  ::spec::proto::runtime::v1::StateItem* _add = _internal_add_states();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.DeleteBulkStateRequest.states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >&
DeleteBulkStateRequest::states() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.DeleteBulkStateRequest.states)
  return states_;
}

// -------------------------------------------------------------------

// SaveStateRequest

// string store_name = 1;
inline void SaveStateRequest::clear_store_name() {
  store_name_.ClearToEmpty();
}
inline const std::string& SaveStateRequest::store_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SaveStateRequest.store_name)
  return _internal_store_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveStateRequest::set_store_name(ArgT0&& arg0, ArgT... args) {
 
 store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.SaveStateRequest.store_name)
}
inline std::string* SaveStateRequest::mutable_store_name() {
  std::string* _s = _internal_mutable_store_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SaveStateRequest.store_name)
  return _s;
}
inline const std::string& SaveStateRequest::_internal_store_name() const {
  return store_name_.Get();
}
inline void SaveStateRequest::_internal_set_store_name(const std::string& value) {
  
  store_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SaveStateRequest::_internal_mutable_store_name() {
  
  return store_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SaveStateRequest::release_store_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.SaveStateRequest.store_name)
  return store_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SaveStateRequest::set_allocated_store_name(std::string* store_name) {
  if (store_name != nullptr) {
    
  } else {
    
  }
  store_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.SaveStateRequest.store_name)
}

// repeated .spec.proto.runtime.v1.StateItem states = 2;
inline int SaveStateRequest::_internal_states_size() const {
  return states_.size();
}
inline int SaveStateRequest::states_size() const {
  return _internal_states_size();
}
inline void SaveStateRequest::clear_states() {
  states_.Clear();
}
inline ::spec::proto::runtime::v1::StateItem* SaveStateRequest::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.SaveStateRequest.states)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >*
SaveStateRequest::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.SaveStateRequest.states)
  return &states_;
}
inline const ::spec::proto::runtime::v1::StateItem& SaveStateRequest::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::spec::proto::runtime::v1::StateItem& SaveStateRequest::states(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.SaveStateRequest.states)
  return _internal_states(index);
}
inline ::spec::proto::runtime::v1::StateItem* SaveStateRequest::_internal_add_states() {
  return states_.Add();
}
inline ::spec::proto::runtime::v1::StateItem* SaveStateRequest::add_states() {
  ::spec::proto::runtime::v1::StateItem* _add = _internal_add_states();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.SaveStateRequest.states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::StateItem >&
SaveStateRequest::states() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.SaveStateRequest.states)
  return states_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StateItem

// string key = 1;
inline void StateItem::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& StateItem::key() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.StateItem.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StateItem::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.StateItem.key)
}
inline std::string* StateItem::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.StateItem.key)
  return _s;
}
inline const std::string& StateItem::_internal_key() const {
  return key_.Get();
}
inline void StateItem::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StateItem::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StateItem::release_key() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.StateItem.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StateItem::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.StateItem.key)
}

// bytes value = 2;
inline void StateItem::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& StateItem::value() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.StateItem.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StateItem::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.StateItem.value)
}
inline std::string* StateItem::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.StateItem.value)
  return _s;
}
inline const std::string& StateItem::_internal_value() const {
  return value_.Get();
}
inline void StateItem::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StateItem::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StateItem::release_value() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.StateItem.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StateItem::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.StateItem.value)
}

// .spec.proto.runtime.v1.Etag etag = 3;
inline bool StateItem::_internal_has_etag() const {
  return this != internal_default_instance() && etag_ != nullptr;
}
inline bool StateItem::has_etag() const {
  return _internal_has_etag();
}
inline void StateItem::clear_etag() {
  if (GetArenaForAllocation() == nullptr && etag_ != nullptr) {
    delete etag_;
  }
  etag_ = nullptr;
}
inline const ::spec::proto::runtime::v1::Etag& StateItem::_internal_etag() const {
  const ::spec::proto::runtime::v1::Etag* p = etag_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::Etag&>(
      ::spec::proto::runtime::v1::_Etag_default_instance_);
}
inline const ::spec::proto::runtime::v1::Etag& StateItem::etag() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.StateItem.etag)
  return _internal_etag();
}
inline void StateItem::unsafe_arena_set_allocated_etag(
    ::spec::proto::runtime::v1::Etag* etag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(etag_);
  }
  etag_ = etag;
  if (etag) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.StateItem.etag)
}
inline ::spec::proto::runtime::v1::Etag* StateItem::release_etag() {
  
  ::spec::proto::runtime::v1::Etag* temp = etag_;
  etag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::Etag* StateItem::unsafe_arena_release_etag() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.StateItem.etag)
  
  ::spec::proto::runtime::v1::Etag* temp = etag_;
  etag_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::Etag* StateItem::_internal_mutable_etag() {
  
  if (etag_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::Etag>(GetArenaForAllocation());
    etag_ = p;
  }
  return etag_;
}
inline ::spec::proto::runtime::v1::Etag* StateItem::mutable_etag() {
  ::spec::proto::runtime::v1::Etag* _msg = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.StateItem.etag)
  return _msg;
}
inline void StateItem::set_allocated_etag(::spec::proto::runtime::v1::Etag* etag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete etag_;
  }
  if (etag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::Etag>::GetOwningArena(etag);
    if (message_arena != submessage_arena) {
      etag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, etag, submessage_arena);
    }
    
  } else {
    
  }
  etag_ = etag;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.StateItem.etag)
}

// map<string, string> metadata = 4;
inline int StateItem::_internal_metadata_size() const {
  return metadata_.size();
}
inline int StateItem::metadata_size() const {
  return _internal_metadata_size();
}
inline void StateItem::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StateItem::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StateItem::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.StateItem.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StateItem::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StateItem::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.StateItem.metadata)
  return _internal_mutable_metadata();
}

// .spec.proto.runtime.v1.StateOptions options = 5;
inline bool StateItem::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool StateItem::has_options() const {
  return _internal_has_options();
}
inline void StateItem::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::spec::proto::runtime::v1::StateOptions& StateItem::_internal_options() const {
  const ::spec::proto::runtime::v1::StateOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::StateOptions&>(
      ::spec::proto::runtime::v1::_StateOptions_default_instance_);
}
inline const ::spec::proto::runtime::v1::StateOptions& StateItem::options() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.StateItem.options)
  return _internal_options();
}
inline void StateItem::unsafe_arena_set_allocated_options(
    ::spec::proto::runtime::v1::StateOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.StateItem.options)
}
inline ::spec::proto::runtime::v1::StateOptions* StateItem::release_options() {
  
  ::spec::proto::runtime::v1::StateOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::StateOptions* StateItem::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.StateItem.options)
  
  ::spec::proto::runtime::v1::StateOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::StateOptions* StateItem::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::StateOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::spec::proto::runtime::v1::StateOptions* StateItem::mutable_options() {
  ::spec::proto::runtime::v1::StateOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.StateItem.options)
  return _msg;
}
inline void StateItem::set_allocated_options(::spec::proto::runtime::v1::StateOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::StateOptions>::GetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.StateItem.options)
}

// -------------------------------------------------------------------

// Etag

// string value = 1;
inline void Etag::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Etag::value() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.Etag.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Etag::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.Etag.value)
}
inline std::string* Etag::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.Etag.value)
  return _s;
}
inline const std::string& Etag::_internal_value() const {
  return value_.Get();
}
inline void Etag::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Etag::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Etag::release_value() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.Etag.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Etag::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.Etag.value)
}

// -------------------------------------------------------------------

// StateOptions

// .spec.proto.runtime.v1.StateOptions.StateConcurrency concurrency = 1;
inline void StateOptions::clear_concurrency() {
  concurrency_ = 0;
}
inline ::spec::proto::runtime::v1::StateOptions_StateConcurrency StateOptions::_internal_concurrency() const {
  return static_cast< ::spec::proto::runtime::v1::StateOptions_StateConcurrency >(concurrency_);
}
inline ::spec::proto::runtime::v1::StateOptions_StateConcurrency StateOptions::concurrency() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.StateOptions.concurrency)
  return _internal_concurrency();
}
inline void StateOptions::_internal_set_concurrency(::spec::proto::runtime::v1::StateOptions_StateConcurrency value) {
  
  concurrency_ = value;
}
inline void StateOptions::set_concurrency(::spec::proto::runtime::v1::StateOptions_StateConcurrency value) {
  _internal_set_concurrency(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.StateOptions.concurrency)
}

// .spec.proto.runtime.v1.StateOptions.StateConsistency consistency = 2;
inline void StateOptions::clear_consistency() {
  consistency_ = 0;
}
inline ::spec::proto::runtime::v1::StateOptions_StateConsistency StateOptions::_internal_consistency() const {
  return static_cast< ::spec::proto::runtime::v1::StateOptions_StateConsistency >(consistency_);
}
inline ::spec::proto::runtime::v1::StateOptions_StateConsistency StateOptions::consistency() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.StateOptions.consistency)
  return _internal_consistency();
}
inline void StateOptions::_internal_set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value) {
  
  consistency_ = value;
}
inline void StateOptions::set_consistency(::spec::proto::runtime::v1::StateOptions_StateConsistency value) {
  _internal_set_consistency(value);
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.StateOptions.consistency)
}

// -------------------------------------------------------------------

// TransactionalStateOperation

// string operationType = 1;
inline void TransactionalStateOperation::clear_operationtype() {
  operationtype_.ClearToEmpty();
}
inline const std::string& TransactionalStateOperation::operationtype() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TransactionalStateOperation.operationType)
  return _internal_operationtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionalStateOperation::set_operationtype(ArgT0&& arg0, ArgT... args) {
 
 operationtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.TransactionalStateOperation.operationType)
}
inline std::string* TransactionalStateOperation::mutable_operationtype() {
  std::string* _s = _internal_mutable_operationtype();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.TransactionalStateOperation.operationType)
  return _s;
}
inline const std::string& TransactionalStateOperation::_internal_operationtype() const {
  return operationtype_.Get();
}
inline void TransactionalStateOperation::_internal_set_operationtype(const std::string& value) {
  
  operationtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionalStateOperation::_internal_mutable_operationtype() {
  
  return operationtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionalStateOperation::release_operationtype() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.TransactionalStateOperation.operationType)
  return operationtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionalStateOperation::set_allocated_operationtype(std::string* operationtype) {
  if (operationtype != nullptr) {
    
  } else {
    
  }
  operationtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operationtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operationtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operationtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.TransactionalStateOperation.operationType)
}

// .spec.proto.runtime.v1.StateItem request = 2;
inline bool TransactionalStateOperation::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool TransactionalStateOperation::has_request() const {
  return _internal_has_request();
}
inline void TransactionalStateOperation::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::spec::proto::runtime::v1::StateItem& TransactionalStateOperation::_internal_request() const {
  const ::spec::proto::runtime::v1::StateItem* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::spec::proto::runtime::v1::StateItem&>(
      ::spec::proto::runtime::v1::_StateItem_default_instance_);
}
inline const ::spec::proto::runtime::v1::StateItem& TransactionalStateOperation::request() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.TransactionalStateOperation.request)
  return _internal_request();
}
inline void TransactionalStateOperation::unsafe_arena_set_allocated_request(
    ::spec::proto::runtime::v1::StateItem* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:spec.proto.runtime.v1.TransactionalStateOperation.request)
}
inline ::spec::proto::runtime::v1::StateItem* TransactionalStateOperation::release_request() {
  
  ::spec::proto::runtime::v1::StateItem* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::spec::proto::runtime::v1::StateItem* TransactionalStateOperation::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.TransactionalStateOperation.request)
  
  ::spec::proto::runtime::v1::StateItem* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::spec::proto::runtime::v1::StateItem* TransactionalStateOperation::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::spec::proto::runtime::v1::StateItem>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::spec::proto::runtime::v1::StateItem* TransactionalStateOperation::mutable_request() {
  ::spec::proto::runtime::v1::StateItem* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.TransactionalStateOperation.request)
  return _msg;
}
inline void TransactionalStateOperation::set_allocated_request(::spec::proto::runtime::v1::StateItem* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::spec::proto::runtime::v1::StateItem>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.TransactionalStateOperation.request)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecuteStateTransactionRequest

// string storeName = 1;
inline void ExecuteStateTransactionRequest::clear_storename() {
  storename_.ClearToEmpty();
}
inline const std::string& ExecuteStateTransactionRequest::storename() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ExecuteStateTransactionRequest.storeName)
  return _internal_storename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteStateTransactionRequest::set_storename(ArgT0&& arg0, ArgT... args) {
 
 storename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.ExecuteStateTransactionRequest.storeName)
}
inline std::string* ExecuteStateTransactionRequest::mutable_storename() {
  std::string* _s = _internal_mutable_storename();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ExecuteStateTransactionRequest.storeName)
  return _s;
}
inline const std::string& ExecuteStateTransactionRequest::_internal_storename() const {
  return storename_.Get();
}
inline void ExecuteStateTransactionRequest::_internal_set_storename(const std::string& value) {
  
  storename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteStateTransactionRequest::_internal_mutable_storename() {
  
  return storename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteStateTransactionRequest::release_storename() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.ExecuteStateTransactionRequest.storeName)
  return storename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteStateTransactionRequest::set_allocated_storename(std::string* storename) {
  if (storename != nullptr) {
    
  } else {
    
  }
  storename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), storename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    storename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.ExecuteStateTransactionRequest.storeName)
}

// repeated .spec.proto.runtime.v1.TransactionalStateOperation operations = 2;
inline int ExecuteStateTransactionRequest::_internal_operations_size() const {
  return operations_.size();
}
inline int ExecuteStateTransactionRequest::operations_size() const {
  return _internal_operations_size();
}
inline void ExecuteStateTransactionRequest::clear_operations() {
  operations_.Clear();
}
inline ::spec::proto::runtime::v1::TransactionalStateOperation* ExecuteStateTransactionRequest::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.ExecuteStateTransactionRequest.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::TransactionalStateOperation >*
ExecuteStateTransactionRequest::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:spec.proto.runtime.v1.ExecuteStateTransactionRequest.operations)
  return &operations_;
}
inline const ::spec::proto::runtime::v1::TransactionalStateOperation& ExecuteStateTransactionRequest::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::spec::proto::runtime::v1::TransactionalStateOperation& ExecuteStateTransactionRequest::operations(int index) const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.ExecuteStateTransactionRequest.operations)
  return _internal_operations(index);
}
inline ::spec::proto::runtime::v1::TransactionalStateOperation* ExecuteStateTransactionRequest::_internal_add_operations() {
  return operations_.Add();
}
inline ::spec::proto::runtime::v1::TransactionalStateOperation* ExecuteStateTransactionRequest::add_operations() {
  ::spec::proto::runtime::v1::TransactionalStateOperation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:spec.proto.runtime.v1.ExecuteStateTransactionRequest.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::spec::proto::runtime::v1::TransactionalStateOperation >&
ExecuteStateTransactionRequest::operations() const {
  // @@protoc_insertion_point(field_list:spec.proto.runtime.v1.ExecuteStateTransactionRequest.operations)
  return operations_;
}

// map<string, string> metadata = 3;
inline int ExecuteStateTransactionRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int ExecuteStateTransactionRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void ExecuteStateTransactionRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExecuteStateTransactionRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExecuteStateTransactionRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.ExecuteStateTransactionRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExecuteStateTransactionRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExecuteStateTransactionRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.ExecuteStateTransactionRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PublishEventRequest

// string pubsub_name = 1;
inline void PublishEventRequest::clear_pubsub_name() {
  pubsub_name_.ClearToEmpty();
}
inline const std::string& PublishEventRequest::pubsub_name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PublishEventRequest.pubsub_name)
  return _internal_pubsub_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventRequest::set_pubsub_name(ArgT0&& arg0, ArgT... args) {
 
 pubsub_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PublishEventRequest.pubsub_name)
}
inline std::string* PublishEventRequest::mutable_pubsub_name() {
  std::string* _s = _internal_mutable_pubsub_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PublishEventRequest.pubsub_name)
  return _s;
}
inline const std::string& PublishEventRequest::_internal_pubsub_name() const {
  return pubsub_name_.Get();
}
inline void PublishEventRequest::_internal_set_pubsub_name(const std::string& value) {
  
  pubsub_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::_internal_mutable_pubsub_name() {
  
  return pubsub_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::release_pubsub_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PublishEventRequest.pubsub_name)
  return pubsub_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublishEventRequest::set_allocated_pubsub_name(std::string* pubsub_name) {
  if (pubsub_name != nullptr) {
    
  } else {
    
  }
  pubsub_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pubsub_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pubsub_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pubsub_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PublishEventRequest.pubsub_name)
}

// string topic = 2;
inline void PublishEventRequest::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& PublishEventRequest::topic() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PublishEventRequest.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventRequest::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PublishEventRequest.topic)
}
inline std::string* PublishEventRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PublishEventRequest.topic)
  return _s;
}
inline const std::string& PublishEventRequest::_internal_topic() const {
  return topic_.Get();
}
inline void PublishEventRequest::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::release_topic() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PublishEventRequest.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublishEventRequest::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PublishEventRequest.topic)
}

// bytes data = 3;
inline void PublishEventRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PublishEventRequest::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PublishEventRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PublishEventRequest.data)
}
inline std::string* PublishEventRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PublishEventRequest.data)
  return _s;
}
inline const std::string& PublishEventRequest::_internal_data() const {
  return data_.Get();
}
inline void PublishEventRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PublishEventRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublishEventRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PublishEventRequest.data)
}

// string data_content_type = 4;
inline void PublishEventRequest::clear_data_content_type() {
  data_content_type_.ClearToEmpty();
}
inline const std::string& PublishEventRequest::data_content_type() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.PublishEventRequest.data_content_type)
  return _internal_data_content_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventRequest::set_data_content_type(ArgT0&& arg0, ArgT... args) {
 
 data_content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.PublishEventRequest.data_content_type)
}
inline std::string* PublishEventRequest::mutable_data_content_type() {
  std::string* _s = _internal_mutable_data_content_type();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.PublishEventRequest.data_content_type)
  return _s;
}
inline const std::string& PublishEventRequest::_internal_data_content_type() const {
  return data_content_type_.Get();
}
inline void PublishEventRequest::_internal_set_data_content_type(const std::string& value) {
  
  data_content_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::_internal_mutable_data_content_type() {
  
  return data_content_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::release_data_content_type() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.PublishEventRequest.data_content_type)
  return data_content_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PublishEventRequest::set_allocated_data_content_type(std::string* data_content_type) {
  if (data_content_type != nullptr) {
    
  } else {
    
  }
  data_content_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_content_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_content_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_content_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.PublishEventRequest.data_content_type)
}

// map<string, string> metadata = 5;
inline int PublishEventRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int PublishEventRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void PublishEventRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PublishEventRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PublishEventRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.PublishEventRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PublishEventRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PublishEventRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.PublishEventRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InvokeBindingRequest

// string name = 1;
inline void InvokeBindingRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& InvokeBindingRequest::name() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeBindingRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeBindingRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.InvokeBindingRequest.name)
}
inline std::string* InvokeBindingRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeBindingRequest.name)
  return _s;
}
inline const std::string& InvokeBindingRequest::_internal_name() const {
  return name_.Get();
}
inline void InvokeBindingRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeBindingRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeBindingRequest::release_name() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeBindingRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeBindingRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeBindingRequest.name)
}

// bytes data = 2;
inline void InvokeBindingRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& InvokeBindingRequest::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeBindingRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeBindingRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.InvokeBindingRequest.data)
}
inline std::string* InvokeBindingRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeBindingRequest.data)
  return _s;
}
inline const std::string& InvokeBindingRequest::_internal_data() const {
  return data_.Get();
}
inline void InvokeBindingRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeBindingRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeBindingRequest::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeBindingRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeBindingRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeBindingRequest.data)
}

// map<string, string> metadata = 3;
inline int InvokeBindingRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int InvokeBindingRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void InvokeBindingRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InvokeBindingRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InvokeBindingRequest::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.InvokeBindingRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InvokeBindingRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InvokeBindingRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.InvokeBindingRequest.metadata)
  return _internal_mutable_metadata();
}

// string operation = 4;
inline void InvokeBindingRequest::clear_operation() {
  operation_.ClearToEmpty();
}
inline const std::string& InvokeBindingRequest::operation() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeBindingRequest.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeBindingRequest::set_operation(ArgT0&& arg0, ArgT... args) {
 
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.InvokeBindingRequest.operation)
}
inline std::string* InvokeBindingRequest::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeBindingRequest.operation)
  return _s;
}
inline const std::string& InvokeBindingRequest::_internal_operation() const {
  return operation_.Get();
}
inline void InvokeBindingRequest::_internal_set_operation(const std::string& value) {
  
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeBindingRequest::_internal_mutable_operation() {
  
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeBindingRequest::release_operation() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeBindingRequest.operation)
  return operation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeBindingRequest::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeBindingRequest.operation)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InvokeBindingResponse

// bytes data = 1;
inline void InvokeBindingResponse::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& InvokeBindingResponse::data() const {
  // @@protoc_insertion_point(field_get:spec.proto.runtime.v1.InvokeBindingResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeBindingResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:spec.proto.runtime.v1.InvokeBindingResponse.data)
}
inline std::string* InvokeBindingResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:spec.proto.runtime.v1.InvokeBindingResponse.data)
  return _s;
}
inline const std::string& InvokeBindingResponse::_internal_data() const {
  return data_.Get();
}
inline void InvokeBindingResponse::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeBindingResponse::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeBindingResponse::release_data() {
  // @@protoc_insertion_point(field_release:spec.proto.runtime.v1.InvokeBindingResponse.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeBindingResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:spec.proto.runtime.v1.InvokeBindingResponse.data)
}

// map<string, string> metadata = 2;
inline int InvokeBindingResponse::_internal_metadata_size() const {
  return metadata_.size();
}
inline int InvokeBindingResponse::metadata_size() const {
  return _internal_metadata_size();
}
inline void InvokeBindingResponse::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InvokeBindingResponse::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InvokeBindingResponse::metadata() const {
  // @@protoc_insertion_point(field_map:spec.proto.runtime.v1.InvokeBindingResponse.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InvokeBindingResponse::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InvokeBindingResponse::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:spec.proto.runtime.v1.InvokeBindingResponse.metadata)
  return _internal_mutable_metadata();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace runtime
}  // namespace proto
}  // namespace spec

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement>() {
  return ::spec::proto::runtime::v1::SequencerOptions_AutoIncrement_descriptor();
}
template <> struct is_proto_enum< ::spec::proto::runtime::v1::UnlockResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spec::proto::runtime::v1::UnlockResponse_Status>() {
  return ::spec::proto::runtime::v1::UnlockResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::spec::proto::runtime::v1::HTTPExtension_Verb> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spec::proto::runtime::v1::HTTPExtension_Verb>() {
  return ::spec::proto::runtime::v1::HTTPExtension_Verb_descriptor();
}
template <> struct is_proto_enum< ::spec::proto::runtime::v1::StateOptions_StateConcurrency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spec::proto::runtime::v1::StateOptions_StateConcurrency>() {
  return ::spec::proto::runtime::v1::StateOptions_StateConcurrency_descriptor();
}
template <> struct is_proto_enum< ::spec::proto::runtime::v1::StateOptions_StateConsistency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spec::proto::runtime::v1::StateOptions_StateConsistency>() {
  return ::spec::proto::runtime::v1::StateOptions_StateConsistency_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_runtime_2eproto
